+++
title = "JVM锁优化"
description = ""
date = 2021-09-09T10:46:14+08:00
featured = false
comment = true
toc = true
reward = true
categories = [
"编程思想"
]
tags =  [
"Java","JVM"
]
series =  [
"Manual"
]
images =  [

]

+++

<!--more-->

### 自旋锁

因此自旋等待的时间必须有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程。自旋次数的默认值是`十次`，用户也可以使用参数-XX：PreBlockSpin来自行更改。

### 自适应锁

自适应意味着自旋的时间不再是固定的了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的。

### 锁消除

锁消除是指虚拟机即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持（第11章已经讲解过逃逸分析技术），如果判断到一段代码中，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以把它们当作栈上数据对待，认为它们是线程私有的，同步加锁自然就无须再进行。(String（StringBuffer） 拼接的例子)

### 锁粗化

如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部，以代码清单13-7为例，就是扩展到第一个append()操作之前直至最后一个append()操作之后，这样只需要加锁一次就可以了。（StringBuffer.append()例子）

### 对象头

HotSpot虚拟机的对象头（ObjectHeader）分为两部分，第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄（GenerationalGCAge）等。这部分数据的长度在32位和64位的Java虚拟机中分别会占用32个或64个比特，官方称它为“MarkWord”。这部分是实现轻量级锁和偏向锁的关键。另外一部分用于存储指向方法区对象类型数据的指针，如果是数组对象，还会有一个额外的部分用于存储数组长度。官方称它为 “Klass Point”

<img src="https://cdn.tkaid.com/img/image-20210909142432896.png" alt="对象头" style="zoom:40%;" />

### 全局安全点

全局安全点（safepoint）这个词我们在GC中经常会提到，简单来说就是其代表了一个状态，在该状态下所有线程都是暂停的，在这个时间点上没有线程在执行字节码。

### 锁状态

锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是锁的升级是`单向的`，也就是说只能从低到高升级，不会出现锁的降级）

偏向锁、轻量级锁的状态转化及对象MarkWord的关系如图

<img src="https://cdn.tkaid.com/img/image-20210909143332042-20210909143549967.png" alt="状态转化" style="zoom: 40%;" />

### 重量级锁

基于monitor，monitor基于操作系统的互斥锁

### 轻量锁

在代码即将进入同步块的时候，如果此同步对象没有被锁定（锁标志位为“01”状态），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（LockRecord）的空间，用于存储锁对象目前的MarkWord的拷贝（官方为这份拷贝加了一个Displaced前缀，即DisplacedMarkWord）

<img src="https://cdn.tkaid.com/img/image-20210909142626364.png" alt="cas操作前" style="zoom: 33%;" />

虚拟机将使用CAS操作尝试把对象的MarkWord更新为指向LockRecord的指针。如果这个更新动作成功了，即代表该线程拥有了这个对象的锁，并且对象MarkWord的锁标志位（MarkWord的最后两个比特）将转变为“00”，表示此对象处于轻量级锁定状态。

如果这个更新操作失败了，那就意味着至少存在一条线程与当前线程竞争获取该对象的锁。虚拟机首先会检查对象的MarkWord是否指向当前线程的栈帧，如果是，说明当前线程已经拥有了这个对象的锁，那直接进入同步块继续执行就可以了，否则就说明这个锁对象已经被其他线程抢占了。如果出现两条以上的线程争用同一个锁的情况，那轻量级锁就不再有效，必须要膨胀为重量级锁。

<img src="https://cdn.tkaid.com/img/image-20210909142722259.png" alt="cas操作后" style="zoom: 33%;" />

它的解锁过程也同样是通过CAS操作来进行的，如果对象的MarkWord仍然指向线程的锁记录，那就用CAS操作把对象当前的MarkWord和线程中复制的DisplacedMarkWord替换回来。假如能够成功替换，那整个同步过程就顺利完成了；如果替换失败，则说明有其他线程尝试过获取该锁，就要在释放锁的同时，唤醒被挂起的线程。

### 偏向锁

- 偏向锁是否开启是可以设置的（启用参数-XX：+UseBiasedLocking）。
- 一个线程反复的去获取/释放一个锁，如果这个锁是轻量级锁或者重量级锁，不断的加解锁显然是没有必要的，造成了资源的浪费。于是引入了偏向锁，偏向锁在获取资源的时候会在资源对象上记录该对象是偏向该线程的，偏向锁并不会主动释放，这样每次偏向锁进入的时候都会判断该资源是否是偏向自己的，如果是偏向自己的则不需要进行额外的操作，直接可以进入同步操作。
- 偏向锁获取过程
  1. 访问Mark Word中偏向锁标志位是否设置成1，锁标志位是否为01——确认为可偏向状态。
  2. 如果为可偏向状态，则测试线程ID是否指向当前线程，如果是，进入步骤（5），否则进入步骤（3）。
  3. 如果线程ID并未指向当前线程，则通过CAS操作竞争锁。如果竞争成功，则将Mark Word中线程ID设置为当前线程ID，然后执行（5）；如果竞争失败，执行（4）。
  4. 如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点（safepoint）时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。
  5. 执行同步代码。

- 偏向锁的释放

  释放需要把握几个要点：`有其他线程竞争`  `JVM到达全局安全点`

  偏向锁的撤销在上述第四步骤中有提到。偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动去释放偏向锁。偏向锁的撤销，需要等待全局安全点safepoint，它会首先暂停拥有偏向锁的线程A，然后判断这个线程A，此时有两种情况

  ![偏向锁的释放](https://cdn.tkaid.com/img/20200411153633541-20210909141620242.png)


## 参考

《深入理解Java虚拟机》

[看完这篇恍然大悟，理解Java中的偏向锁，轻量级锁，重量级锁](https://blog.csdn.net/DBC_121/article/details/105453101)
