---
title: "ZooKeeper能做什么"
date: 2021-08-27T11:15:10+08:00
draft: false
reward: true
categories: [
"编程思想"
]
tags : [
"ZK"
]
series : [
"Manual"
]
images : [
"images/center.png"
]
---

# ZooKeeper能做什么？

什么是`ZooKeeper`?[官网](https://zookeeper.apache.org/)介绍到：`ZooKeeper is a centralized service for maintaining configuration information, naming, providing distributed synchronization, and providing group services.` 这大概描述了Zookeeper主要可以干哪些事情：配置管理，名字服务，提供分布式同步以及集群管理。

## 1. 配置管理

`配置管理`又被称为`发布-订阅`。

在我们的应用中除了代码外，还有一些就是各种配置。比如数据库连接等。一般我们都是使用配置文件的方式，在代码中引入这些配置文件。但是当我们只有一种配置，只有一台服务器，并且不经常修改的时候，使用配置文件是一个很好的做法，但是如果我们配置非常多，有很多服务器都需要这个配置，而且还可能是动态的话使用配置文件就不是个好主意了。这个时候往往需要寻找一种集中管理配置的方法，我们在这个集中的地方修改了配置，所有对这个配置感兴趣的都可以获得变更。比如我们可以把配置放在数据库里，然后所有需要配置的服务都去这个数据库读取配置。但是，因为很多服务的正常运行都非常依赖这个配置，所以需要这个集中提供配置服务的服务具备很高的可靠性。一般我们可以用一个集群来提供这个配置服务，但是用集群提升可靠性，那如何保证配置在集群中的一致性呢？ 这个时候就需要使用一种实现了一致性协议的服务了。Zookeeper就是这种服务，它使用Zab这种一致性协议来提供一致性。现在有很多开源项目使用Zookeeper来维护配置，比如在HBase中，客户端就是连接一个Zookeeper，获得必要的HBase集群的配置信息，然后才可以进一步操作。还有在开源的消息队列Kafka中，也使用Zookeeper来维护broker的信息。

应用中用到的一些配置信息放到ZK上进行集中管理。这类场景通常是这样：应用在启动的时候会主动来获取一次配置，同时，在节点上注册一个Watcher，这样一来，以后每次配置有更新的时候，都会实时通知到订阅的客户端，从来达到获取最新配置信息的目的。

## 2. 命名服务

`命名服务`也是分布式系统中比较常见的一类场景。在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。被命名的实体通常可以是集群中的机器，提供的服务地址，远程对象等等——这些我们都可以统称他们为名字（Name）。其中较为常见的就是一些分布式服务框架中的服务地址列表。通过调用ZK提供的创建节点的API，能够很容易创建一个全局唯一的path，这个path就可以作为一个名称。

阿里巴巴集团开源的分布式服务框架`Dubbo`中使用ZooKeeper来作为其命名服务，维护全局的服务地址列表，[点击这里](http://code.alibabatech.com/wiki/display/dubbo/Home)查看Dubbo开源项目。在Dubbo实现中： 服务提供者在启动的时候，向ZK上的指定节点`/dubbo/${serviceName}/providers`目录下写入自己的URL地址，这个操作就完成了服务的发布。 服务消费者启动的时候，订阅`/dubbo/${serviceName}/providers`目录下的提供者URL地址， 并向`/dubbo/${serviceName} /consumers`目录下写入自己的URL地址。 注意，所有向ZK上注册的地址都是临时节点，这样就能够保证服务提供者和消费者能够自动感应资源的变化。
另外，Dubbo还有针对服务粒度的监控，方法是订阅`/dubbo/${serviceName}`目录下所有提供者和消费者的信息。

## 3. 分布式锁

`分布式锁`，这个主要得益于`ZooKeeper`为我们保证了数据的强一致性。锁服务可以分为两类，一个是`保持独占`（排他锁），另一个是`控制时序`（共享锁/读锁）。

所谓`保持独占`（排他锁），就是所有试图来获取这个锁的客户端，最终只有一个可以成功获得这把锁。通常的做法是把zk上的一个znode看作是一把锁，通过create znode的方式来实现。所有客户端都去创建 `/distribute_lock`节点，最终成功创建的那个客户端也即拥有了这把锁。

`控制时序`（共享锁/读锁）是指所有试图来获取这个锁的客户端，最终都是会被安排执行，只是有个全局时序了。做法和上面基本类似，只是这里`/distribute_lock`已经预先存在，客户端在它下面创建临时有序节点（这个可以通过节点的属性控制：`CreateMode.EPHEMERAL_SEQUENTIAL`来指定）。Zk的父节点（/distribute_lock）维持一份sequence,保证子节点创建的时序性，从而也形成了每个客户端的全局时序。

## 4. 集群管理

在分布式的集群中，经常会由于各种原因，比如硬件故障，软件故障，网络问题，有些节点会进进出出。有新的节点加入进来，也有老的节点退出集群。这个时候，集群中其他机器需要感知到这种变化，然后根据这种变化做出对应的决策。

### 4.1 Master选举

`Master选举`则是ZooKeeper中最为经典的应用场景了。比如 HDFS 中 Active NameNode 的选举。在分布式环境中，相同的业务应用分布在不同的机器上，有些业务逻辑（例如一些耗时的计算，网络I/O处理），往往只需要让整个集群中的某一台机器进行执行，其余机器可以共享这个结果，这样可以大大减少重复劳动，提高性能，于是这个master选举便是这种场景下的碰到的主要问题。

利用ZooKeeper的强一致性，能够保证在分布式高并发情况下节点创建的全局唯一性，即：同时有多个客户端请求创建 `/currentMaster`节点，最终一定只有一个客户端请求能够创建成功。利用这个特性，就能很轻易的在分布式环境中进行集群Master选举了。成功创建该节点的客户端所在的机器就成为了Master。同时，其他没有成功创建该节点的客户端，都会在该节点上注册一个子节点变更的 Watcher，用于监控当前 Master 机器是否存活，一旦发现当前的Master挂了，那么其他客户端将会重新进行 Master 选举。这样就实现了 Master 的动态选举。

### 4.2 集群机器监控

这通常用于那种对集群中机器状态，机器在线率有较高要求的场景，能够快速对集群中机器变化作出响应。这样的场景中，往往有一个监控系统，实时检测集群机器是否存活。过去的做法通常是：监控系统通过某种手段（比如ping）定时检测每个机器，或者每个机器自己定时向监控系统汇报“我还活着”。这种做法可行，但是存在两个比较明显的问题：

- 将会产生一定的时延（受心跳长短限制）;
- 当集群中的节点发生变更时，其余的节点都需要对维护的集群文件（状态表）进行修改，修改内容多。

利用ZooKeeper有两个特性，就可以实时另一种集群机器存活性监控系统：

- 客户端在节点 `x` 上注册一个Watcher，那么如果`x`的子节点变化了，会通知该客户端。
- 创建EPHEMERAL类型的节点，一旦客户端和服务器的会话结束或过期，那么该节点就会消失。

例如，监控系统在`/clusterServers`节点上注册一个Watcher，以后每动态加机器，那么就往`/clusterServers`下创建一个 `EPHEMERAL`类型的节点：`/clusterServers/{hostname}`. 这样，监控系统就能够实时知道机器的增减情况，至于后续处理就是监控系统的业务了。

## 参考链接

[【分布式解决方案】ZooKeeper经典应用场景](https://juejin.im/post/6844903862684352525)

[Zookeeper-Zookeeper可以干什么](https://www.cnblogs.com/yuyijq/p/3424473.html)

[ZooKeeper典型应用场景一览](http://jm.taobao.org/2011/10/08/1232/)
