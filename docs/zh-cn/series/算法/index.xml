<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ç®—æ³• on ğŸ‡¨ğŸ‡³ç¤¾ä¼šä¸»ä¹‰æ ¸å¿ƒä»·å€¼è§‚ğŸ‡¨ğŸ‡³</title>
    <link>https://xuzhijvn.github.io/zh-cn/series/%E7%AE%97%E6%B3%95/</link>
    <description>Recent content in ç®—æ³• on ğŸ‡¨ğŸ‡³ç¤¾ä¼šä¸»ä¹‰æ ¸å¿ƒä»·å€¼è§‚ğŸ‡¨ğŸ‡³</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>Copyright Â© 2016-{year} Razon Yang. All Rights Reserved.</copyright>
    <lastBuildDate>Sat, 09 Oct 2021 14:38:30 +0800</lastBuildDate><atom:link href="https://xuzhijvn.github.io/zh-cn/series/%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>TopK</title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/code/algorithm/topk/</link>
      <pubDate>Sat, 09 Oct 2021 14:38:30 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/code/algorithm/topk/</guid>
      <description>public static int topK(int[] arr, int k) { if (arr == null || k &amp;gt; arr.length || arr.length == 0 || k &amp;lt;= 0) { return -1; } PriorityQueue&amp;lt;Integer&amp;gt; queue = new PriorityQueue&amp;lt;&amp;gt;(k, Comparator.reverseOrder()); for (int i = 0; i &amp;lt; k; i++) { queue.add(arr[i]); } for (int i = k; i &amp;lt; arr.length; i++) { if (queue.peek() &amp;gt; arr[i]) { queue.poll(); queue.add(arr[i]); } } return queue.peek(); } </description>
    </item>
    
    <item>
      <title>LRUCache</title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/code/algorithm/lrucache/</link>
      <pubDate>Sat, 09 Oct 2021 14:24:56 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/code/algorithm/lrucache/</guid>
      <description>public class LRUCache&amp;lt;K,V&amp;gt;{ private final int cap; private final Map&amp;lt;K,V&amp;gt; map; private final LinkedList&amp;lt;K&amp;gt; list; public LRUCache(int cap) { this.cap = cap; map = new HashMap&amp;lt;&amp;gt;(cap); list = new LinkedList&amp;lt;&amp;gt;(); } public void put(K key, V value) { if (map.size() == cap){ K first = list.removeFirst(); map.remove(first); } list.addLast(key); map.put(key, value); } public V get(K key) { V value = map.get(key); if (value == null){ return null; }else { list.remove(key); list.</description>
    </item>
    
    <item>
      <title>300. æœ€é•¿é€’å¢å­åºåˆ—</title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/code/algorithm/leetcode/300.-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/code/algorithm/leetcode/300.-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</guid>
      <description>class Solution { public int lengthOfLIS(int[] nums) { if (nums == null || nums.length == 0){return 0;} int[] dp = new int[nums.length]; Arrays.fill(dp,1); for (int i = 0; i &amp;lt; nums.length; i++) { for (int j = 0; j &amp;lt; i; j++) { if(nums[i] &amp;gt; nums[j] &amp;amp;&amp;amp; dp[j] + 1 &amp;gt; dp[i]){ dp[i] = dp[j] + 1; } } } return Arrays.stream(dp).max().getAsInt(); } } 300. æœ€é•¿é€’å¢å­åºåˆ— </description>
    </item>
    
    <item>
      <title>å‰‘æŒ‡ Offer 09. ç”¨ä¸¤ä¸ªæ ˆå®ç°é˜Ÿåˆ—</title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/code/algorithm/leetcode/%E5%89%91%E6%8C%87-offer-09.-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/code/algorithm/leetcode/%E5%89%91%E6%8C%87-offer-09.-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</guid>
      <description>class CQueue { Stack&amp;lt;Integer&amp;gt; stack1; Stack&amp;lt;Integer&amp;gt; stack2; public CQueue() { stack1 = new Stack(); stack2 = new Stack(); } public void appendTail(int value) { stack1.push(value); } public int deleteHead() { if(stack2.isEmpty()){ while(stack1.isEmpty() == false){ stack2.push(stack1.pop()); } } if(stack2.isEmpty()){ return -1; }else{ return stack2.pop(); } } } /** * Your CQueue object will be instantiated and called as such: * CQueue obj = new CQueue(); * obj.appendTail(value); * int param_2 = obj.</description>
    </item>
    
    <item>
      <title>å‰‘æŒ‡ Offer 18. åˆ é™¤é“¾è¡¨çš„èŠ‚ç‚¹</title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/code/algorithm/leetcode/%E5%89%91%E6%8C%87-offer-18.-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/code/algorithm/leetcode/%E5%89%91%E6%8C%87-offer-18.-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/</guid>
      <description>class CQueue { Stack&amp;lt;Integer&amp;gt; stack1; Stack&amp;lt;Integer&amp;gt; stack2; public CQueue() { stack1 = new Stack(); stack2 = new Stack(); } public void appendTail(int value) { stack1.push(value); } public int deleteHead() { if(stack2.isEmpty()){ while(stack1.isEmpty() == false){ stack2.push(stack1.pop()); } } if(stack2.isEmpty()){ return -1; }else{ return stack2.pop(); } } } /** * Your CQueue object will be instantiated and called as such: * CQueue obj = new CQueue(); * obj.appendTail(value); * int param_2 = obj.</description>
    </item>
    
    <item>
      <title>å‰‘æŒ‡ Offer 27. äºŒå‰æ ‘çš„é•œåƒ</title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/code/algorithm/leetcode/%E5%89%91%E6%8C%87-offer-27.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/code/algorithm/leetcode/%E5%89%91%E6%8C%87-offer-27.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</guid>
      <description>å‰‘æŒ‡ Offer 27. äºŒå‰æ ‘çš„é•œåƒ /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public TreeNode mirrorTree(TreeNode root) { if(root == null){ return root; } TreeNode posL = root.left; TreeNode posR = root.right; root.left = posR; root.right = posL; mirrorTree(root.left); mirrorTree(root.right); return root; } } </description>
    </item>
    
    <item>
      <title>å‰‘æŒ‡ Offer 28. å¯¹ç§°çš„äºŒå‰æ ‘</title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/code/algorithm/leetcode/%E5%89%91%E6%8C%87-offer-28.-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/code/algorithm/leetcode/%E5%89%91%E6%8C%87-offer-28.-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public boolean isSymmetric(TreeNode root) { if(root == null){return true;} return isSymmetric2(root.left, root.right); } private boolean isSymmetric2(TreeNode left, TreeNode right){ if (left == null &amp;amp;&amp;amp; right == null){return true;} if ((left == null &amp;amp;&amp;amp; right !</description>
    </item>
    
    <item>
      <title>å‰‘æŒ‡ Offer 30. åŒ…å«minå‡½æ•°çš„æ ˆ</title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/code/algorithm/leetcode/%E5%89%91%E6%8C%87-offer-30.-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/code/algorithm/leetcode/%E5%89%91%E6%8C%87-offer-30.-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</guid>
      <description>å‰‘æŒ‡ Offer 30. åŒ…å«minå‡½æ•°çš„æ ˆ class MinStack { Stack&amp;lt;Integer&amp;gt; stack1; Stack&amp;lt;Integer&amp;gt; stack2; /** initialize your data structure here. */ public MinStack() { stack1 = new Stack(); stack2 = new Stack(); } public void push(int x) { stack1.push(x); if(stack2.isEmpty()){ stack2.push(x); }else if(x &amp;gt; stack2.peek()){ stack2.push(stack2.peek()); }else{ stack2.push(x); } } public void pop() { stack1.pop(); stack2.pop(); } public int top() { return stack1.peek(); } public int min() { return stack2.peek(); } } /** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.</description>
    </item>
    
    <item>
      <title>å‰‘æŒ‡ Offer 32 - I. ä»ä¸Šåˆ°ä¸‹æ‰“å°äºŒå‰æ ‘</title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/code/algorithm/leetcode/%E5%89%91%E6%8C%87-offer-32-i.-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/code/algorithm/leetcode/%E5%89%91%E6%8C%87-offer-32-i.-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public static int[] levelOrder(TreeNode root) { ArrayList&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;Integer&amp;gt;(); if (root == null) { return new int[]{}; } Queue&amp;lt;TreeNode&amp;gt; queue=new LinkedList&amp;lt;TreeNode&amp;gt;(); queue.add(root); while(!queue.isEmpty()){ TreeNode node=queue.poll(); list.add(node.val); if(node.left!=null){ queue.add(node.left); } if(node.right!=null){ queue.add(node.right); } } int[] res = new int[list.</description>
    </item>
    
    <item>
      <title>å‰‘æŒ‡ Offer 32 - II. ä»ä¸Šåˆ°ä¸‹æ‰“å°äºŒå‰æ ‘ II</title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/code/algorithm/leetcode/%E5%89%91%E6%8C%87-offer-32-ii.-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-ii/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/code/algorithm/leetcode/%E5%89%91%E6%8C%87-offer-32-ii.-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-ii/</guid>
      <description>å‰‘æŒ‡ Offer 32 - II. ä»ä¸Šåˆ°ä¸‹æ‰“å°äºŒå‰æ ‘ II class Solution { public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; levelOrder(TreeNode root) { Queue&amp;lt;TreeNode&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;(); List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); if(root != null) queue.add(root); while(!queue.isEmpty()) { List&amp;lt;Integer&amp;gt; tmp = new ArrayList&amp;lt;&amp;gt;(); for(int i = queue.size(); i &amp;gt; 0; i--) { TreeNode node = queue.poll(); tmp.add(node.val); if(node.left != null) queue.add(node.left); if(node.right != null) queue.add(node.right); } res.add(tmp); } return res; } } </description>
    </item>
    
    <item>
      <title>å‰‘æŒ‡ Offer 32 - III. ä»ä¸Šåˆ°ä¸‹æ‰“å°äºŒå‰æ ‘ III</title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/code/algorithm/leetcode/%E5%89%91%E6%8C%87-offer-32-iii.-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-iii/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/code/algorithm/leetcode/%E5%89%91%E6%8C%87-offer-32-iii.-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-iii/</guid>
      <description>å‰‘æŒ‡ Offer 32 - III. ä»ä¸Šåˆ°ä¸‹æ‰“å°äºŒå‰æ ‘ III package com.xzj; import java.util.*; /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public static List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; levelOrder(TreeNode root) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); if (root == null){return res;} Stack&amp;lt;TreeNode&amp;gt; stack1 = new Stack(); Stack&amp;lt;TreeNode&amp;gt; stack2 = new Stack(); stack1.push(root); while (stack1.</description>
    </item>
    
    <item>
      <title>æŸ¥æ‰¾é‡å¤å…ƒç´ </title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/code/algorithm/nowcoder/%E6%9F%A5%E6%89%BE%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/code/algorithm/nowcoder/%E6%9F%A5%E6%89%BE%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</guid>
      <description>æ‰¾å‡ºæ•°ç»„ arr ä¸­é‡å¤å‡ºç°è¿‡çš„å…ƒç´ ï¼ˆä¸ç”¨è€ƒè™‘è¿”å›é¡ºåºï¼‰
ç¤ºä¾‹1
è¾“å…¥ [1, 2, 4, 4, 3, 3, 1, 5, 3] è¾“å‡º [1, 3, 4] å°†ä¼ å…¥çš„æ•°ç»„arrä¸­çš„æ¯ä¸€ä¸ªå…ƒç´ valueå½“ä½œå¦å¤–ä¸€ä¸ªæ–°æ•°ç»„bçš„keyï¼Œç„¶åéå†arrå»è®¿é—®b[value]ï¼Œè‹¥b[value]ä¸å­˜åœ¨ï¼Œåˆ™å°†b[value]è®¾ç½®ä¸º1ï¼Œè‹¥b[value]å­˜åœ¨ï¼Œåˆ™å°†å…¶åŠ 1ã€‚å¯ä»¥æƒ³è±¡ï¼Œè‹¥arrä¸­æ•°ç»„æ²¡æœ‰é‡å¤çš„å…ƒç´ ï¼Œåˆ™bæ•°ç»„ä¸­æ‰€æœ‰å…ƒç´ å‡ä¸º1ï¼›è‹¥arræ•°ç»„ä¸­å­˜åœ¨é‡å¤çš„å…ƒç´ ï¼Œåˆ™åœ¨ç¬¬äºŒæ¬¡è®¿é—®è¯¥b[value]æ—¶ï¼Œb[value]ä¼šåŠ 1ï¼Œå…¶å€¼å°±ä¸º2äº†ã€‚æœ€åéå†bæ•°ç»„ï¼Œå°†å…¶å€¼å¤§äº1çš„å…ƒç´ çš„keyå­˜å…¥å¦ä¸€ä¸ªæ•°ç»„aä¸­ï¼Œå°±å¾—åˆ°äº†arrä¸­é‡å¤çš„å…ƒç´ ã€‚
function duplicates(arr) { //å£°æ˜ä¸¤ä¸ªæ•°ç»„ï¼Œaæ•°ç»„ç”¨æ¥å­˜æ”¾ç»“æœï¼Œbæ•°ç»„ç”¨æ¥å­˜æ”¾arrä¸­æ¯ä¸ªå…ƒç´ çš„ä¸ªæ•°  var a = [],b = []; //éå†arrï¼Œå¦‚æœä»¥arrä¸­å…ƒç´ ä¸ºä¸‹æ ‡çš„çš„bå…ƒç´ å·²å­˜åœ¨ï¼Œåˆ™è¯¥bå…ƒç´ åŠ 1ï¼Œå¦åˆ™è®¾ç½®ä¸º1  for(var i = 0; i &amp;lt; arr.length; i++){ if(!b[arr[i]]){ b[arr[i]] = 1; continue; } b[arr[i]]++; } //éå†bæ•°ç»„ï¼Œå°†å…¶ä¸­å…ƒç´ å€¼å¤§äº1çš„å…ƒç´ ä¸‹æ ‡å­˜å…¥aæ•°ç»„ä¸­  for(var i = 0; i &amp;lt; b.length; i++){ if(b[i] &amp;gt; 1){ a.push(i); } } return a; } æŸ¥æ‰¾é‡å¤å…ƒç´  </description>
    </item>
    
  </channel>
</rss>
