<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Other on 唯有光頭才能變強</title>
    <link>https://xuzhijvn.github.io/zh-cn/tags/other/</link>
    <description>Recent content in Other on 唯有光頭才能變強</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>Copyright © 2016-{year} Razon Yang. All Rights Reserved.</copyright>
    <lastBuildDate>Fri, 27 Aug 2021 11:15:10 +0800</lastBuildDate><atom:link href="https://xuzhijvn.github.io/zh-cn/tags/other/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Centos Linux清理磁盘空间</title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/%E5%85%B6%E4%BB%96/centos-linux%E6%B8%85%E7%90%86%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/%E5%85%B6%E4%BB%96/centos-linux%E6%B8%85%E7%90%86%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4/</guid>
      <description>Centos Linux清理磁盘空间
 df -hl 查看占比  [root@VM-0-12-centos apioak-document]# df -hl Filesystem Size Used Avail Use% Mounted on devtmpfs 1.9G 0 1.9G 0% /dev tmpfs 1.9G 24K 1.9G 1% /dev/shm tmpfs 1.9G 788K 1.9G 1% /run tmpfs 1.9G 0 1.9G 0% /sys/fs/cgroup /dev/vda1 50G 48G 0 100% / tmpfs 379M 0 379M 0% /run/user/0 overlay 50G 48G 0 100% /var/lib/docker/overlay2/b3b7c9bcd6a086d488f5ca533ec7fc934f863340e4efa40513c354f3a13c6ccd/merged shm 64M 0 64M 0% /var/lib/docker/containers/76627689f39c84201d3554e95cf7a8ca53bc53f660fbf1127d86c49db2a67591/mounts/shm overlay 50G 48G 0 100% /var/lib/docker/overlay2/f3fac618fb01637e586b483c87d9075d1cb08bee9c9d1f3afffd0a012394b067/merged shm 64M 0 64M 0% /var/lib/docker/containers/36172ef8f5a337d595f41fda4a2e7864b333278a9d2102b700d7f2a6f47c52a8/mounts/shm 在根目录执行du -sh *  [root@VM-0-12-centos /]# du -sh * 0	bin 147M	boot 987M	data 0	dev 6.</description>
    </item>
    
    <item>
      <title>CSS中内联SVG</title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/%E5%85%B6%E4%BB%96/css%E4%B8%AD%E5%86%85%E8%81%94svg/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/%E5%85%B6%E4%BB%96/css%E4%B8%AD%E5%86%85%E8%81%94svg/</guid>
      <description>CSS中内联SVG
内联SVG比内联图像的base64效果更好，图片更加保真：
.icon-arrow-down { width: 20px; height: 20px; background: url(&amp;#39;data:image/svg+xml;utf8,&amp;lt;svg version=&amp;#34;1.1&amp;#34; xmlns=&amp;#34;http://www.w3.org/2000/svg&amp;#34; width=&amp;#34;200&amp;#34; height=&amp;#34;200&amp;#34; viewBox=&amp;#34;0 0 200 200&amp;#34;&amp;gt;&amp;lt;path fill=&amp;#34;#00A5E0&amp;#34; d=&amp;#34;M145.659,68.949c-5.101-5.208-13.372-5.208-18.473,0L99.479,97.233 L71.772,68.949c-5.1-5.208-13.371-5.208-18.473,0c-5.099,5.208-5.099,13.648,0,18.857l46.18,47.14l46.181-47.14 C150.759,82.598,150.759,74.157,145.659,68.949z&amp;#34;/&amp;gt;&amp;lt;/svg&amp;gt;&amp;#39;) no-repeat center; background-size: 100%; } </description>
    </item>
    
    <item>
      <title>docker-compose.yml文件详解</title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/%E5%85%B6%E4%BB%96/docker-compose.yml%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/%E5%85%B6%E4%BB%96/docker-compose.yml%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</guid>
      <description>docker-compose.yml文件详解
Compose和Docker兼容性： Compose 文件格式有3个版本,分别为1, 2.x 和 3.x 目前主流的为 3.x 其支持 docker 1.13.0 及其以上的版本 常用参数： version  # 指定 compose 文件的版本 services  # 定义所有的 service 信息, services 下面的第一级别的 key 既是一个 service 的名称 build  # 指定包含构建上下文的路径, 或作为一个对象，该对象具有 context 和指定的 dockerfile 文件以及 args 参数值 context # context: 指定 Dockerfile 文件所在的路径 dockerfile # dockerfile: 指定 context 指定的目录下面的 Dockerfile 的名称(默认为 Dockerfile) args # args: Dockerfile 在 build 过程中需要的参数 (等同于 docker container build --build-arg 的作用) cache_from  # v3.</description>
    </item>
    
    <item>
      <title>docker-compose网络设置</title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/%E5%85%B6%E4%BB%96/docker-compose%E7%BD%91%E7%BB%9C%E8%AE%BE%E7%BD%AE/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/%E5%85%B6%E4%BB%96/docker-compose%E7%BD%91%E7%BB%9C%E8%AE%BE%E7%BD%AE/</guid>
      <description>Docker Compose 网络设置
基本概念 默认情况下，Compose 会为我们的应用创建一个网络，服务的每个容器都会加入该网络中。这样，容器就可被该网络中的其他容器访问，不仅如此，该容器还能以服务名称作为 hostname 被其他容器访问。
默认情况下，应用程序的网络名称基于 Compose 的工程名称，而项目名称基于 docker-compose.yml 所在目录的名称。如需修改工程名称，可使用&amp;ndash;project-name 标识或 COMPOSE_PORJECT_NAME 环境变量。
举个例子，假如一个应用程序在名为 myapp 的目录中，并且 docker-compose.yml 如下所示：
version: &amp;#39;2&amp;#39; services: web: build: . ports: - &amp;#34;8000:8000&amp;#34; db: image: postgres 当我们运行 docker-compose up 时，将会执行以下几步：
- 创建一个名为 myapp_default 的网络； - 使用 web 服务的配置创建容器，它以“web”这个名称加入网络 myapp_default； - 使用 db 服务的配置创建容器，它以“db”这个名称加入网络 myapp_default。
容器间可使用服务名称（web 或 db）作为 hostname 相互访问。例如，web 这个服务可使用postgres://db:5432 访问 db 容器。
更新容器 当服务的配置发生更改时，可使用 docker-compose up 命令更新配置。
此时，Compose 会删除旧容器并创建新容器。新容器会以不同的 IP 地址加入网络，名称保持不变。任何指向旧容器的连接都会被关闭，容器会重新找到新容器并连接上去。
links 前文讲过，默认情况下，服务之间可使用服务名称相互访问。links 允许我们定义一个别名，从而使用该别名访问其他服务。举个例子：</description>
    </item>
    
    <item>
      <title>gitbook安装</title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/%E5%85%B6%E4%BB%96/gitbook%E5%AE%89%E8%A3%85/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/%E5%85%B6%E4%BB%96/gitbook%E5%AE%89%E8%A3%85/</guid>
      <description>gitbook安装
 安装  sudo npm install gitbook -g sudo npm install -g gitbook-cli 验证  gitbook -V 初始化项目  mkdir direName //创建自己的文件夹目录 cd direName //进入到自己的gitbook文件夹目录 gitbook init //初始化gitbook项目 启动  gitbook serve 或者gitbook serve &amp;amp;后台运行，默认在4000端口启动。</description>
    </item>
    
    <item>
      <title>iptables: No chain/target/match by that name.</title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/%E5%85%B6%E4%BB%96/iptables_-no-chain_target_match-by-that-name/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/%E5%85%B6%E4%BB%96/iptables_-no-chain_target_match-by-that-name/</guid>
      <description>iptables: No chain/target/match by that name.
重启redis镜像的时候报错如下：
ERROR: for redis Cannot start service redis: driver failed programming external connectivity on endpoint redis (f5211771e5a0ee705edb72f8a8dfbca2503456ab0e8330a32932b029a7c0568d): (iptables failed: iptables --wait -t nat -A DOCKER -p tcp -d 0/0 --dport 6379 -j DNAT --to-destination 192.168.80.2:6379 ! -i br-fbefac0273aa: iptables: No chain/target/match by that name. 原因：
docker 服务启动的时候，docker服务会向iptables注册一个链，以便让docker服务管理的containner所暴露的端口之间进行通信。通过命令iptables -L可以查看iptables 链。如果你删除了iptables中的docker链，或者iptables的规则被丢失了（例如重启firewalld，我就是使用了systemctl stop iptables导致链丢失），docker就会报这个错误。
解决办法：
systemctl restart docker 重启docker服务，之后，正确的iptables规则就会被创建出来。
参考：
Docker 启动时报错：iptables:No chain/target/match by the name</description>
    </item>
    
    <item>
      <title>Linux配置git账号密码</title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/%E5%85%B6%E4%BB%96/linux%E9%85%8D%E7%BD%AEgit%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/%E5%85%B6%E4%BB%96/linux%E9%85%8D%E7%BD%AEgit%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81/</guid>
      <description>Linux配置git账号密码
1. 在~/下， touch创建文件 .git-credentials, 用vim编辑此文件 touch .git-credentials vim .git-credentials 在里面按“i”然后输入： https://{username}:{password}@github.com 比如 https://account:password@github.com 2. 在终端下执行 git config --global credential.helper store 3. 可以看到~/.gitconfig文件，会多了一项 [credential] helper = store </description>
    </item>
    
    <item>
      <title>navicat远程连接mysql，2003 can&#39;t connect to mysql server on 10038</title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/%E5%85%B6%E4%BB%96/navicat%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5mysql2003-can_t-connect-to-mysql-serve/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/%E5%85%B6%E4%BB%96/navicat%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5mysql2003-can_t-connect-to-mysql-serve/</guid>
      <description>navicat远程连接mysql，2003 can&amp;rsquo;t connect to mysql server on 10038
首先我们通过
①：netstat -an|grep 3306
来查看mysql默认的端口3306是否开启，允许哪个ip使用，如果你发现，前面有127.0.0.1，就说明，3306端口只能本机ip使用
所以，我们需要
②：打开mysql配置文件vi /etc/mysql/mysql.conf.d/mysqld.cnf
将bind-address = 127.0.0.1注销
③：进入mysql，对远程用户进行授权，
grant all privileges on . to &amp;lsquo;root&amp;rsquo;@&#39;%&#39; identified by &amp;lsquo;xxxxxx&amp;rsquo;;
这里的root 是你远程登录的用户，xxxxxx是你登录使用的密码，然后可以在mysql数据 表中查看到你这个用户已经被添加到user表中
④：service mysql restart</description>
    </item>
    
    <item>
      <title>net::ERR_CONTENT_LENGTH_MISMATCH 200 (OK)</title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/%E5%85%B6%E4%BB%96/net__err_content_length_mismatch-200-ok/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/%E5%85%B6%E4%BB%96/net__err_content_length_mismatch-200-ok/</guid>
      <description>net::ERR_CONTENT_LENGTH_MISMATCH 200 (OK)
加载静态资源时报错：net::ERR_CONTENT_LENGTH_MISMATCH 200 (OK)
解决办法：调整缓冲区大小 proxy_buffer_size 64k; proxy_buffers 4 32k; proxy_busy_buffers_size 64k;
server { listen 80; server_name tkaid.com www.tkaid.com; location / { proxy_buffer_size 64k; proxy_buffers 4 32k; proxy_busy_buffers_size 64k; proxy_pass http://k8s_tkb-web-svc; } } 如果仍然报这个错，可以再将值设置得大一点。</description>
    </item>
    
    <item>
      <title>nginx反向代理kibana报：Kibana did not load properly.Check the server output for more information.</title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/%E5%85%B6%E4%BB%96/nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86kibana%E6%8A%A5kibana-did-not-load-properly.chec/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/%E5%85%B6%E4%BB%96/nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86kibana%E6%8A%A5kibana-did-not-load-properly.chec/</guid>
      <description>nginx反向代理kibana报：Kibana did not load properly.Check the server output for more information.
如题所述，直接访问5601端口不会报错，一旦用ngnix反向代理就报错。
原因：应该是kibana的启动用户没有访问nginx/proxy_temp文件夹的权限，导致部分静态资源无法加载。
 奇怪的是：1. 我的proxy_temp文件下一个文件都没有 2. 我的nginx error.log日志也没有报类似Permission denied的错误。 这里暂且不管。。。
 解决办法:
chmod -R 777 proxy_temphttps://www.cnblogs.com/operationhome/p/9901580.html</description>
    </item>
    
    <item>
      <title>Ubuntu修改ip</title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/%E5%85%B6%E4%BB%96/ubuntu%E4%BF%AE%E6%94%B9ip/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/%E5%85%B6%E4%BB%96/ubuntu%E4%BF%AE%E6%94%B9ip/</guid>
      <description>Ubuntu修改ip
方式一 这种方式可以修改ip地址，不能访问互联网；虚拟机100必须以这种方式配置（101、102、103是复制100而来）
1、sudo vi /etc/netplan/50-cloud-init.yaml
network: ethernets: enp0s3: addresses: [10.0.2.15/24] dhcp4: true enp0s8: addresses: [192.168.56.100/24] dhcp4: false version: 2 2、重启虚拟机
方式二 这种方式可以修改ip地址，能访问互联网；虚拟机101、102、103以这种方式配置
1、注释50-cloud-init.yaml里面的修改
2、sudo vim /etc/network/interfaces
# This file describes the network interfaces available on your system # and how to activate them. For more information, see interfaces(5). source /etc/network/interfaces.d/* # The loopback network interface auto lo iface lo inet loopback # The primary network interface(NAT) auto enp0s3 iface enp0s3 inet dhcp # 增加的Host-only静态IP设置 (enp0s8 是根据拓扑关系映射的网卡名称（旧规则是eth0,eth1）) # 可以通过 ```ls /sys/class/net```查看，是否为enp0s8 auto enp0s8 iface enp0s8 inet static address 192.</description>
    </item>
    
    <item>
      <title>Ubuntu修改域名解析</title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/%E5%85%B6%E4%BB%96/ubuntu%E4%BF%AE%E6%94%B9%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/%E5%85%B6%E4%BB%96/ubuntu%E4%BF%AE%E6%94%B9%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/</guid>
      <description>1、vim /etc/resolv.conf
nameserver 8.8.8.8 nameserver 114.114.114.114 nameserver 1.2.4.8 2、vim /etc/network/interfaces
dns-nameserver 8.8.8.8 dns-nameserver 114.114.114.114 dns-nameserver 1.2.4.8 3、/etc/init.d/networking restart</description>
    </item>
    
    <item>
      <title>为什么需要protobuf</title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E6%8B%BE%E9%81%97/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81protobuf/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E6%8B%BE%E9%81%97/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81protobuf/</guid>
      <description>为什么需要protobuf  protobuf采用字节编码，而json, xml都是字符编码，字节编码更加节省空间 采用了varint编码，进一步降低了编码后的空间大小  Varint就是一种对数字进行编码的方法，编码后二进制数据是不定长的，数值越小的数字使用的字节数越少。例如对于int32_t，采用Varint编码后需要1~5个bytes，小的数字使用1个byte，大的数字使用5个bytes。基于实际场景中小数字的使用远远多于大数字，因此通过Varint编码对于大部分场景都可以起到一个压缩的效果。</description>
    </item>
    
    <item>
      <title>使用Xshell登录AWS的EC2云服务器和开启EC2上允许root&#43;密码方式登录</title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/%E5%85%B6%E4%BB%96/%E4%BD%BF%E7%94%A8xshell%E7%99%BB%E5%BD%95aws%E7%9A%84ec2%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E5%BC%80%E5%90%AFec2%E4%B8%8A%E5%85%81%E8%AE%B8root&#43;%E5%AF%86%E7%A0%81%E6%96%B9%E5%BC%8F%E7%99%BB%E5%BD%95/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/%E5%85%B6%E4%BB%96/%E4%BD%BF%E7%94%A8xshell%E7%99%BB%E5%BD%95aws%E7%9A%84ec2%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E5%BC%80%E5%90%AFec2%E4%B8%8A%E5%85%81%E8%AE%B8root&#43;%E5%AF%86%E7%A0%81%E6%96%B9%E5%BC%8F%E7%99%BB%E5%BD%95/</guid>
      <description>使用Xshell登录AWS的EC2云服务器和开启EC2上允许root+密码方式登录 https://www.dwhd.org/20150525_182436.html</description>
    </item>
    
    <item>
      <title>全文索引</title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E6%8B%BE%E9%81%97/%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E6%8B%BE%E9%81%97/%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95/</guid>
      <description>全文索引 参考 什么是全文索引，为什么要使用全文索引MySQL 之全文索引浅谈mysql fulltext全文索引优缺点</description>
    </item>
    
    <item>
      <title>阿里云下配置MySQL远程连接</title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/%E5%85%B6%E4%BB%96/%E9%98%BF%E9%87%8C%E4%BA%91%E4%B8%8B%E9%85%8D%E7%BD%AEmysql%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/%E5%85%B6%E4%BB%96/%E9%98%BF%E9%87%8C%E4%BA%91%E4%B8%8B%E9%85%8D%E7%BD%AEmysql%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/</guid>
      <description>1）use mysql 2）将host设置为%表示任何ip都能连接mysql update user set host=&amp;#39;%&amp;#39; where user=&amp;#39;root&amp;#39; and host=&amp;#39;localhost&amp;#39;; 3) 执行完以上语句,接着执行以下语句 ,刷新权限表,使配置生效 flush privileges; 参考链接： 阿里云下配置MySQL远程连接的步骤详解</description>
    </item>
    
    <item>
      <title>高性能无锁队列Disruptor</title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E6%8B%BE%E9%81%97/%E9%AB%98%E6%80%A7%E8%83%BD%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97disruptor/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E6%8B%BE%E9%81%97/%E9%AB%98%E6%80%A7%E8%83%BD%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97disruptor/</guid>
      <description>高性能无锁队列Disruptor 1. JDK中的队列 在jdk中的队列都实现了java.util.Queue接口，在队列中又分为两类，一类是线程不安全的，ArrayDeque，LinkedList等等，还有一类都在java.util.concurrent包下属于线程安全，而在我们真实的环境中，我们的机器都是属于多线程，当多线程对同一个队列进行排队操作的时候，如果使用线程不安全会出现，覆盖数据，数据丢失等无法预测的事情，所以我们这个时候只能选择线程安全的队列。在jdk中提供的线程安全的队列下面简单列举部分队列:
   队列名字 是否加锁 数据结构 关键技术点 是否有锁 是否有界     ArrayBlockingQueue 是 数组array ReentrantLock 有锁 有界   LinkedBlockingQueue 是 链表 ReentrantLock 有锁 有界   LinkedTransferQueue 否 链表 CAS 无锁 无界   ConcurrentLinkedQueue 否 链表 CAS 无锁 无界    我们可以看见，我们无锁的队列是无界的，有锁的队列是有界的，这里就会涉及到一个问题，我们在真正的线上环境中，无界的队列，对我们系统的影响比较大，有可能会导致我们内存直接溢出，所以我们首先得排除无界队列，当然并不是无界队列就没用了，只是在某些场景下得排除。其次还剩下ArrayBlockingQueue，LinkedBlockingQueue两个队列，他们两个都是用ReentrantLock控制的线程安全，他们两个的区别一个是数组，一个是链表，在队列中，一般获取这个队列元素之后紧接着会获取下一个元素，或者一次获取多个队列元素都有可能，而数组在内存中地址是连续的，在操作系统中会有缓存的优化(下面也会介绍缓存行)，所以访问的速度会略胜一筹，我们也会尽量去选择ArrayBlockingQueue。而事实证明在很多第三方的框架中，比如早期的log4j异步，都是选择的ArrayBlockingQueue。
当然ArrayBlockingQueue，也有自己的弊端，就是性能比较低，为什么jdk会增加一些无锁的队列，其实就是为了增加性能，很苦恼，又需要无锁，又需要有界，这个时候恐怕会忍不住说一句你咋不上天呢？但是还真有人上天了。
2.Disruptor Disruptor就是上面说的那个天，Disruptor是英国外汇交易公司LMAX开发的一个高性能队列，并且是一个开源的并发框架，并获得2011Duke’s程序框架创新奖。能够在无锁的情况下实现网络的Queue并发操作，基于Disruptor开发的系统单线程能支撑每秒600万订单。目前，包括Apache Storm、Camel、Log4j2等等知名的框架都在内部集成了Disruptor用来替代jdk的队列，以此来获得高性能。
3.1为什么这么牛逼？ 上面已经把Disruptor吹出了花了，你肯定会产生疑问，他真的能有这么牛逼吗，我的回答是当然的，在Disruptor中有三大杀器:
  CAS
  消除伪共享
  RingBuffer
有了这三大杀器，Disruptor才变得如此牛逼。
  3.1.1 锁和CAS CAS实现无锁队列可以参考👉无锁队列的实现我们ArrayBlockingQueue为什么会被抛弃的一点，就是因为用了重量级lock锁，在我们加锁过程中我们会把锁挂起，解锁后，又会把线程恢复,这一过程会有一定的开销，并且我们一旦没有获取锁，这个线程就只能一直等待，这个线程什么事也不能做。</description>
    </item>
    
  </channel>
</rss>
