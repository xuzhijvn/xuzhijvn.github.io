<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on 唯有光頭才能變強</title>
    <link>https://xuzhijvn.github.io/zh-cn/tags/java/</link>
    <description>Recent content in Java on 唯有光頭才能變強</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>Copyright © 2016-{year} Razon Yang. All Rights Reserved.</copyright>
    <lastBuildDate>Fri, 27 Aug 2021 11:15:10 +0800</lastBuildDate><atom:link href="https://xuzhijvn.github.io/zh-cn/tags/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>AQS</title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/java/aqs/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/java/aqs/</guid>
      <description>Java并发之AQS详解 并发之AQS原理(二) CLH队列与Node解析 从ReentrantLock的实现看AQS的原理及应用 </description>
    </item>
    
    <item>
      <title>CompletableFuture使用详解</title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/java/completablefuture%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/java/completablefuture%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/</guid>
      <description>1、 runAsync 和 supplyAsync方法 CompletableFuture 提供了四个静态方法来创建一个异步操作。
public static CompletableFuture&amp;lt;Void&amp;gt; runAsync(Runnable runnable) public static CompletableFuture&amp;lt;Void&amp;gt; runAsync(Runnable runnable, Executor executor) public static &amp;lt;U&amp;gt; CompletableFuture&amp;lt;U&amp;gt; supplyAsync(Supplier&amp;lt;U&amp;gt; supplier) public static &amp;lt;U&amp;gt; CompletableFuture&amp;lt;U&amp;gt; supplyAsync(Supplier&amp;lt;U&amp;gt; supplier, Executor executor) 没有指定Executor的方法会使用ForkJoinPool.commonPool() 作为它的线程池执行异步代码。如果指定线程池，则使用指定的线程池运行。以下所有的方法都类同。
 runAsync方法不支持返回值。 supplyAsync可以支持返回值。  示例 //无返回值 public static void runAsync() throws Exception { CompletableFuture&amp;lt;Void&amp;gt; future = CompletableFuture.runAsync(() -&amp;gt; { try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { } System.out.println(&amp;#34;run end ...&amp;#34;); }); future.get(); } //有返回值 public static void supplyAsync() throws Exception { CompletableFuture&amp;lt;Long&amp;gt; future = CompletableFuture.</description>
    </item>
    
    <item>
      <title>HashMap和HashTable区别</title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/java/hashmap%E5%92%8Chashtable%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/java/hashmap%E5%92%8Chashtable%E5%8C%BA%E5%88%AB/</guid>
      <description>1、HashMap是HashTable的轻量级版本， HashTable是线程安全的，其方法都被synchronized关键同步
2、 HashMap 把 Hashtable 的 contains 方法去掉了，改成 containsValue 和 containsKey。因为 contains 方法容易让人引起误解。
3、 HashMap允许将 null 作为一个 entry 的 key 或者 value，而 Hashtable 不允许。
4、HashTable 继承自 Dictionary 类，而 HashMap 是 Java1.2 引进的 Map interface 的一个实现。
5、Hashtable 和 HashMap 采用的 hash/rehash 算法都大概一样，所以性能不会有很大的差异。</description>
    </item>
    
    <item>
      <title>java agent</title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/java/java-agent/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/java/java-agent/</guid>
      <description>**开发者可以构建一个独立于应用程序的代理程序（Agent），用来监测和协助运行在 JVM 上的程序，甚至能够替换和修改某些类的定义。**有了这样的功能，开发者就可以实现更为灵活的运行时虚拟机监控和 Java 类操作了，这样的特性实际上提供了 一种虚拟机级别支持的 AOP 实现方式，使得开发者无需对 JDK 做任何升级和改动，就可以实现某些 AOP 的功能了。
1.1 JVM启动前静态Instrument 未完待续。。。</description>
    </item>
    
    <item>
      <title>Java switch表达式支持的数据类型</title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/java/java-switch%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%94%AF%E6%8C%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/java/java-switch%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%94%AF%E6%8C%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description>switch(expression){ case value : //语句  break; //可选  case value : //语句  break; //可选  //你可以有任意数量的case语句  default : //可选  //语句 } 这里的 expression 支持：
1、基本数据类型：byte, short, char, int
2、包装数据类型：Byte, Short, Character, Integer
3、枚举类型：Enum
4、 字符串类型：String（Jdk 7+ 开始支持）
为什么不支持long、float、double数据类型？
switch 底层是使用 int 型 来进行判断的，即使是枚举、String类型，最终也是转变成 int 型。由于 long、float、double 型表示范围大于 int 型，因此不支持 long、float、double 类型。 （String类型最终是转成了int类型的hashCode；枚举最终转成了枚举对象的定义顺序，即 ordinal值）
下面举一个使用包装类型和枚举的，其实也不难，注意只能用在 switch 块里面
// 使用包装类型 Integer value = 5; switch (value) { case 3: System.</description>
    </item>
    
    <item>
      <title>Java协程</title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/java/java%E5%8D%8F%E7%A8%8B/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/java/java%E5%8D%8F%E7%A8%8B/</guid>
      <description>参考 为什么 Java 坚持多线程不选择协程？ Kotlin 协程真的比 Java 线程更高效吗？ 硬核系列 | 深入剖析 Java 协程 Golang 的 协程调度机制 与 GOMAXPROCS 性能调优 </description>
    </item>
    
    <item>
      <title>Java反射</title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/java/java%E5%8F%8D%E5%B0%84/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/java/java%E5%8F%8D%E5%B0%84/</guid>
      <description>反射可以在程序运行过程中动态的构造类、获取类的全部信息、调用类型方法。但是，为什么我们要这么做呢？需要构造类，new就好了，需要访问类成员变量、调用方法，直接访问、调用就好了，为什么要通过一大堆反射代码去实现呢？
通常，class在编译期间就确定，JVM在运行时通过类加载器加载确定的class。如果在运行时才确定需要加载什么类，就需要利用java反射。java反射使得程序更加灵活，类似spring的框架将类以全限定名的形成配置在配置文件，然后再通过反射实例化。
参考：
https://blog.csdn.net/Appleyk/article/details/77879073 </description>
    </item>
    
    <item>
      <title>Java堆外内存溢出</title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/java/java%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/java/java%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/</guid>
      <description>前段时间在做一个实时人脸抓拍项目的时候，遇到了一个堆外内存OOM的问题，现在把思路好好整理一下。
项目中用opencv通过rtsp协议，实时的读取通用网络摄像头的视频帧。因为项目中多处用到了org.opencv.core.Mat这个对象，而Mat对象的构造是通过调用native方法实现的，也就是说构造Mat对象的时候，会在堆外分配内存：
//  // C++: Mat::Mat()  //  // javadoc: Mat::Mat()  public Mat() { nativeObj = n_Mat(); return; } // C++: Mat::Mat()  private static native long n_Mat(); 堆外分配的内存不受JVM的内存管理。由于又没有主动调用Mat.realse()去释放堆外内存，导致堆外内存OOM。
其实解决的办法很简单，可以在Mat对象使用完毕后直接调用Mat.realse()释放堆外内存。（没有试过，本人使用的下面的方式）
但是，Mat对象充斥着整个项目，要跟踪Mat对象的生命周期显得有点复杂，而且因为太多地方使用了Mat对象，很有可能遗漏调用Mat.realse()释放内存。因此，还是想把这部分内存的释放交由JVM来做，具体的方式是：定期的调用System.gc()执行垃圾回收（很多人说System.gc()只是建议JVM执行垃圾回收，并不是命令，是否执行取决去JVM自己，但是，经我实测，每次调用System.gc()都会触发垃圾回收。），JVM在垃圾回收前会执行每个**空java对象（null）**的finalize()方法，而Mat对象的finalize()方法正好实现了释放内存的逻辑：
@Override protected void finalize() throws Throwable { n_delete(nativeObj); super.finalize(); } // native support for java finalize()  private static native void n_delete(long nativeObj); 因为会定时的调用System.gc()触发Full GC, 而Full GC的之前会调用那些不再被引用的Mat对象的finalize()方法释放它的堆外内存，所以间接的实现了由JVM释放堆外内存的目的。
但是，这种做法并不好，因为通过System.gc()强制定期执行Full GC，势必会影响java应用本身。
为何一定要复制到DirectByteBuffer来读写（系统调用）？
GC会回收无用对象，同时还会进行碎片整理，移动对象在内存中的位置，来减少内存碎片。DirectByteBuffer不受GC控制。如果不用DirectByteBuffer而是用HeapByteBuffer，如果在调用系统调用时，发生了GC，导致HeapByteBuffer内存位置发生了变化，但是内核态并不能感知到这个变化导致系统调用读取或者写入错误的数据。所以一定要通过不受GC影响的DirectByteBuffer来进行IO系统调用。
假设我们要从网络中读入一段数据，再把这段数据发送出去的话，采用Non-direct ByteBuffer的流程是这样的：
网络 –&amp;gt; 临时的DirectByteBuffer –&amp;gt; 应用 Non-direct ByteBuffer –&amp;gt; 临时的Direct ByteBuffer –&amp;gt; 网络</description>
    </item>
    
    <item>
      <title>Java如何绑定线程到指定CPU上执行</title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/java/java%E5%A6%82%E4%BD%95%E7%BB%91%E5%AE%9A%E7%BA%BF%E7%A8%8B%E5%88%B0%E6%8C%87%E5%AE%9Acpu%E4%B8%8A%E6%89%A7%E8%A1%8C/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/java/java%E5%A6%82%E4%BD%95%E7%BB%91%E5%AE%9A%E7%BA%BF%E7%A8%8B%E5%88%B0%E6%8C%87%E5%AE%9Acpu%E4%B8%8A%E6%89%A7%E8%A1%8C/</guid>
      <description>不知道你是啥感觉，但是我第一次看到这个问题的时候，我是懵逼的。
而且它还是一个面试题。
我懵逼倒不是因为我不知道答案，而是恰好我之前在非常机缘巧合的情况下知道了答案。
我感觉非常的冷门，作为一个考察候选者的知识点出现在面试环节中不太合适，除非是候选者主动提起做过这样的优化。
而且怕就怕面试官也是恰巧在某个书上或者博客中知道这个东西，稍微的看了一下，以为自己学到了绝世武功，然后拿出去考别人。
这样不合适。
说回这个题目。
正常来说，其实应该是属于考察操作系统的知识点范畴。
但是面试官呢又特定的加了“在 Java 中如何实现”。
那我们就聊聊这个问题。
Java线程 在聊如何绑定之前，先铺垫一个相关的背景知识：Java线程的实现。
其实我们都知道 Thread 类的大部分方法都是 native 方法：
在 Java 中一个方法被声明为 native 方法，绝大部分情况下说明这个方法没有或者不能使用平台无关的手段来实现。
说明需要操作的是很底层的东西了，已经脱离了 Java 语言层面的范畴。
抛开 Java 语言这个大前提，实现线程主要是有三种方式：
 1.使用内核线程实现（1:1实现） 2.使用用户线程实现（1:N实现） 3.使用用户线程加轻量级进程混合实现（N:M实现）
 这三种实现方案，在《深入理解Java虚拟机》的 12.4 小节有详细的描述，有兴趣的同学可以去仔细的翻阅一下。
总之，你要知道的是虽然有这三种不同的线程模型，但是 Java 作为上层应用，其实是感知不到这三种模型之间的区别的。
JVM 规范里面也没有规定，必须使用哪一种模型。
因为操作系统支持是怎样的线程模型，很大程度上决定了运行在上面的 Java 虚拟机的线程怎样去映射，但是这一点在不同的平台上很难达成一致。
所以JVM 规范里面没有、也不好去规定 Java 线程需要使用哪种线程模型来实现。
同时关于本文要讨论的话题，我在知乎上也找到了类似的问题：
 https://www.zhihu.com/question/64072646/answer/216184631  这里面有一个R大的回答，大家可以看看一下。
他也是先从线程模型的角度铺垫了一下。
我这里主要说一下使用内核线程实现（1:1实现）的这个模型。
因为我们用的最多的 HotSpot 虚拟机，就是采用 1:1 模型来实现 Java 线程的。
这是个啥意思呢？
说人话就是一个 Java 线程是直接映射为一个操作系统原生线程的，中间没有额外的间接结构。HotSpot 虚拟机也不干涉线程的调度，这事全权交给底下的操作系统去做。
顶多就是设置一个线程优先级，操作系统来调度的时候给个建议。</description>
    </item>
    
    <item>
      <title>Java安装指南</title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/java/java%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/java/java%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/</guid>
      <description>1. 下载JDK 进入Oracle 官方网站 下载合适的 JDK 版本，准备安装。
2. 创建目录 执行如下命令，在 /usr/ 目录下创建 java 目录。
mkdir /usr/java cd /usr/java 将下载的文件 jdk-8u151-linux-x64.tar.gz 复制到 /usr/java/ 目录下。
3. 解压 JDK tar -zxvf jdk-8u151-linux-x64.tar.gz 4. 设置环境变量 set java environment JAVA_HOME=/usr/java/jdk1.8.0_151 JRE_HOME=/usr/java/jdk1.8.0_151/jre CLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin export JAVA_HOME JRE_HOME CLASS_PATH PATH 使修改生效：
source /etc/profile 5. 测试 执行如下命令进行测试。
java -version 若显示 Java 版本信息，则说明 JDK 安装成功：
java version &amp;#34;1.8.0_151&amp;#34; Java(TM) SE Runtime Environment (build 1.8.0_151-b12) Java HotSpot(TM) 64-Bit Server VM (build 25.</description>
    </item>
    
    <item>
      <title>Java对象的hashCode方法</title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/java/java%E5%AF%B9%E8%B1%A1%E7%9A%84hashcode%E6%96%B9%E6%B3%95/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/java/java%E5%AF%B9%E8%B1%A1%E7%9A%84hashcode%E6%96%B9%E6%B3%95/</guid>
      <description>java中的Object类的hashCode方法是一个native方法，查看native源码过于困难，所以暂且认为 Object类的hashCode生成规则是：hash(对象的内存地址+一些其他信息)
java中String类的 hashCode方法 比较直观，源码如下：
public int hashCode() { int h = hash; if (h == 0 &amp;amp;&amp;amp; value.length &amp;gt; 0) { char val[] = value; for (int i = 0; i &amp;lt; value.length; i++) { h = 31 * h + val[i]; } hash = h; } return h; } 生成规则：s[0]*31^(n-1) + s[1]*31^(n-2) + &amp;hellip; + s[n-1]
为什么是素数31？
素数：根据素数的特点，一个数与素数相乘，得到结果只能被1、这个数、素数本身整除。因此，按照 s[0]*31^(n-1) + s[1]*31^(n-2) + &amp;hellip; + s[n-1] 生成的hashCode越不容易发生碰撞。
31：哈希计算速度快。可用移位和减法来代替乘法。现代的VM可以自动完成这种优化，如31 * i = (i &amp;laquo; 5) - i。</description>
    </item>
    
    <item>
      <title>JIT即时编译</title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/java/jit%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/java/jit%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91/</guid>
      <description>1. 编译器与解释器 不做特别说明的话，我们讲的，
编译器：程序运行前将其编译成机器码的程序
解释器：程序运作中逐行解释源码得到结果的程序
 特别注意的是，解释器也是一个程序，输入源码，输出结果，并没有显示的将源码转换成机器码的过程 解释器与 JIT  无论是编译器还是解释器，从 源码 到结果都需要将源码经过：词法分析 -&amp;gt; 语法分析 -&amp;gt; 语义分析 处理，
一个比较简单的编译器的处理步骤看起来：
编译流程： 源码 [字符流] - 词法分析 -&amp;gt; 单词（token）流 - 语法分析 -&amp;gt; 语法树 / 抽象语法树 - 语义分析 -&amp;gt; 标注了属性的抽象语法树 - 代码生成 -&amp;gt; 目标代码 执行流程： 目标代码 - 操作系统/硬件 -&amp;gt; 执行结果 狭义的解释器处理步骤看起来：
解释执行流程： 源码 [字符流] - 需要做词法分析+语法分析+类型检查的字符流解释器 -&amp;gt; 执行结果  特别注意的是，解释器真正的输入往往并直接是源码，使用解释器实现的编程语言实现里，通常：
 至少会在解释执行前做完语法分析，然后通过树解释器来实现解释执行； 兼顾易于实现、跨平台、执行效率这几点，会选择使用字节码解释器实现解释执行。  为什么大多数解释器都将AST转化成字节码再用虚拟机执行，而不是直接解释AST？  2. 解释型语言 很多资料会说，Python、Ruby、JavaScript都是“解释型语言”，是通过解释器来实现的。这么说其实很容易引起误解：语言一般只会定义其抽象语义，而不会强制性要求采用某种实现方式。
例如说C一般被认为是“编译型语言”，但C的解释器也是存在的，例如Ch 。同样，C++也有解释器版本的实现，例如Cint 。
一般被称为“解释型语言”的是主流实现为解释器的语言，但并不是说它就无法编译。例如说经常被认为是“解释型语言”的Scheme 就有好几种编译器实现，其中率先支持R6RS 规范的大部分内容的是Ikarus ，支持在x86上编译Scheme；它最终不是生成某种虚拟机的字节码，而是直接生成x86机器码。</description>
    </item>
    
    <item>
      <title>OOM实战</title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/java/oom%E5%AE%9E%E6%88%98/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/java/oom%E5%AE%9E%E6%88%98/</guid>
      <description>《深入理解Java虚拟机》中将OOM划分为: Java堆溢出、虚拟机栈和本地方法栈溢出、方法区和运行时常量池溢出、本机直接内存溢出
1. Java堆溢出 /** * JDK1.6/JDK1.8 * * Java堆内存溢出异常测试 * * VM Args: -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError * * @author xuzhijun.online * @date 2019年4月22日 */ public class HeapOOM { static class OOMObject{ } public static void main(String[] args) { List&amp;lt;OOMObject&amp;gt; list = new ArrayList&amp;lt;OOMObject&amp;gt;(); while(true) { list.add(new OOMObject()); } } } 运行结果：
java.lang.OutOfMemoryError: Java heap space Dumping heap to java_pid3404.hprof ... Heap dump file created [22045981 bytes in 0.663 secs] 处理方法：</description>
    </item>
    
    <item>
      <title>ThreadLocal</title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/java/threadlocal/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/java/threadlocal/</guid>
      <description>ThreadLocal 是一个线程的本地变量，也就意味着这个变量是线程独有的，是不能与其他线程共享的，这样就可以避免资源竞争带来的多线程的问题，这种解决多线程的安全问题和lock(这里的lock 指通过synchronized 或者Lock 等实现的锁) 是有本质的区别的:
 lock 的资源是多个线程共享的，所以访问的时候需要加锁。 ThreadLocal 是每个线程都有一个副本，是不需要加锁的。 lock 是通过时间换空间的做法。 ThreadLocal 是典型的通过空间换时间的做法。  当然他们的使用场景也是不同的，关键看你的资源是需要多线程之间共享的还是单线程内部共享的。
ThreadLocal 的使用是非常简单的，看下面的代码：
public class Test { public static void main(String[] args) { ThreadLocal&amp;lt;String&amp;gt; local = new ThreadLocal&amp;lt;&amp;gt;(); //设置值  local.set(&amp;#34;hello word&amp;#34;); //获取刚刚设置的值  System.out.println(local.get()); } } ThreadLocal的数据结构 为什么ThreadLocalMap 采用开放地址法来解决哈希冲突? ThreadLocal 往往存放的数据量不会特别大，这个时候开放地址法简单的结构会显得更省空间（链地址法需要额外的指针空间）
ThreadLocal应用场景 传递参数 ThreadLocal用于传递参数及优势 保证线程安全 SimpleDateFormat是线程不安全的，例如下面的写法会报错：
日期转换的一个工具类
public class DateUtil { private static final SimpleDateFormat sdf = new SimpleDateFormat(&amp;quot;yyyy-MM-dd HH:mm:ss&amp;quot;); public static Date parse(String dateStr) { Date date = null; try { date = sdf.</description>
    </item>
    
    <item>
      <title>ThreadLocal线程单例</title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/java/threadlocal%E7%BA%BF%E7%A8%8B%E5%8D%95%E4%BE%8B/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/java/threadlocal%E7%BA%BF%E7%A8%8B%E5%8D%95%E4%BE%8B/</guid>
      <description>ThreadLocal 保证的是单个线程内部访问的是同一个实例，不同线程访问的不是同一个实例。
package test; public class Singleton { private static final ThreadLocal&amp;lt;Singleton&amp;gt; singleton = new ThreadLocal&amp;lt;Singleton&amp;gt;() { @Override protected Singleton initialValue() { return new Singleton(); } }; public static Singleton getInstance() { return singleton.get(); } private Singleton() { } } package test; public class T implements Runnable { @Override public void run() { Singleton instance = Singleton.getInstance(); System.out.println(instance); } } 测试类：
package test; public class Test { public static void main(String[] args){ System.</description>
    </item>
    
    <item>
      <title>ThreadPoolExecutor</title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/java/threadpoolexecutor/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/java/threadpoolexecutor/</guid>
      <description>构造方法 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&amp;lt;Runnable&amp;gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) { if (corePoolSize &amp;lt; 0 || maximumPoolSize &amp;lt;= 0 || maximumPoolSize &amp;lt; corePoolSize || keepAliveTime &amp;lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.acc = System.getSecurityManager() == null ? null : AccessController.getContext(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.</description>
    </item>
    
    <item>
      <title>【转】你了解的可见性可能是错的</title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/java/%E8%BD%AC%E4%BD%A0%E4%BA%86%E8%A7%A3%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E5%8F%AF%E8%83%BD%E6%98%AF%E9%94%99%E7%9A%84/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/java/%E8%BD%AC%E4%BD%A0%E4%BA%86%E8%A7%A3%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E5%8F%AF%E8%83%BD%E6%98%AF%E9%94%99%E7%9A%84/</guid>
      <description>背景 这篇文章最开始再我的群里面有讨论过，当时想写的这篇文章的，但是因为一些时间的关系所以便没有写。最近阅读微信文章的时候发现了一篇零度写的一篇文章《分享一道阿里Java并发面试题》，对于有关Java并发性技术的文章我一般还是挺感兴趣的，于是阅读了一下，整体来说还是挺不错的，但是其中犯了一个验证可见性的问题。由于微信文章回复不方便讨论，于是我便把之前一些和群友的讨论在这里写出来。
如何测试可见性问题 因为在群里面我们习惯的有每周一问，也就由我或者群友发现一些由意思的问题然后提问给大家，让大家参与讨论，当时我提出了一个如何测试vlolatile可见性的问题，首先在Effective Java给出了一个测试volatile可见性的例子:
import java.util.concurrent.*; public class Test { private static /*volatile*/ boolean stop = false; public static void main(String[] args) throws Exception { Thread t = new Thread(new Runnable() { public void run() { int i = 0; while (!stop) { i++; // System.out.println(&amp;#34;hello&amp;#34;);  } } }); t.start(); Thread.sleep(1000); TimeUnit.SECONDS.sleep(1); System.out.println(&amp;#34;Stop Thread&amp;#34;); stop = true; } } 这里大家可以复制上面的代码，你会发现这里程序永远不会结束，在零度的那篇文章中也给出了一个测试可见性的例子:
public class ThreadSafeCache { int result; public int getResult() { return result; } public synchronized void setResult(int result) { this.</description>
    </item>
    
    <item>
      <title>实现线程超时的几种方式</title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/java/%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E8%B6%85%E6%97%B6%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/java/%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E8%B6%85%E6%97%B6%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</guid>
      <description>1. 基于线程的join(long millis)方法 其实这个方法比较牵强，因为它主要作用是用来多个线程之间进行同步的。但因为它提供了这个带参数的方法（所以这也给了我们一个更广泛的思路，就是一般带有超时参数的方法我们都可以尝试着用它来实现超时结束任务），所以我们可以用它来实现。注意这里的参数的单位是固定的毫秒，不同于接下来的带单位的函数。具体用法请看示例：
public class JoinTest { public static void main(String[] args) { Task task1 = new Task(&amp;#34;one&amp;#34;, 4); Task task2 = new Task(&amp;#34;two&amp;#34;, 2); Thread t1 = new Thread(task1); Thread t2 = new Thread(task2); t1.start(); try { t1.join(2000); // 在主线程中等待t1执行2秒  } catch (InterruptedException e) { System.out.println(&amp;#34;t1 interrupted when waiting join&amp;#34;); e.printStackTrace(); } t1.interrupt(); // 这里很重要，一定要打断t1,因为它已经执行了2秒。  t2.start(); try { t2.join(1000); } catch (InterruptedException e) { System.out.println(&amp;#34;t2 interrupted when waiting join&amp;#34;); e.</description>
    </item>
    
    <item>
      <title>对象初始化顺序</title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/java/%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/java/%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F/</guid>
      <description>Java中类及方法的加载顺序 Java类加载顺序 </description>
    </item>
    
    <item>
      <title>泛型</title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/java/%E6%B3%9B%E5%9E%8B/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/java/%E6%B3%9B%E5%9E%8B/</guid>
      <description>泛型的好处  提供了一种类型安全检测机制 提升程序可读性  通配符 通配符的出现是为了指定泛型中的类型范围。
通配符有 3 种形式。
 &amp;lt;?&amp;gt;被称作无限定的通配符。 &amp;lt;? extends T&amp;gt;被称作有上限的通配符。 &amp;lt;? super T&amp;gt;被称作有下限的通配符。   ? 其实代表的是未知类型，所以涉及到 ? 时的操作，一定与具体类型无关。
有人说，&amp;lt;?&amp;gt;提供了只读的功能，也就是它删减了增加具体类型元素的能力，只保留与具体类型无关的功能。它不管装载在这个容器内的元素是什么类型，它只关心元素的数量、容器是否为空？我想这种需求还是很常见的吧。
有同学可能会想，&amp;lt;?&amp;gt;既然作用这么渺小，那么为什么还要引用它呢？ 
个人认为，提高了代码的可读性，程序员看到这段代码时，就能够迅速对此建立极简洁的印象，能够快速推断源码作者的意图。
类型擦除 在泛型类被类型擦除的时候，之前泛型类中的类型参数部分如果没有指定上限，如 &amp;lt;T&amp;gt;则会被转译成普通的 Object 类型，如果指定了上限如 &amp;lt;T extends String&amp;gt;则类型参数就被替换成类型上限。
类型擦除带来的局限性 正常情况下，因为泛型的限制，编译器不让最后一行代码编译通过，因为类似不匹配，但是，基于对类型擦除的了解，利用反射，我们可以绕过这个限制。
那么，利用反射，我们绕过编译器去调用 add 方法。
public class ToolTest { public static void main(String[] args) { List&amp;lt;Integer&amp;gt; ls = new ArrayList&amp;lt;&amp;gt;(); ls.add(23); //	ls.add(&amp;#34;text&amp;#34;);  try { Method method = ls.getClass().getDeclaredMethod(&amp;#34;add&amp;#34;,Object.class); method.invoke(ls,&amp;#34;test&amp;#34;); method.invoke(ls,42.9f); } catch (NoSuchMethodException e) { // TODO Auto-generated catch block  e.</description>
    </item>
    
    <item>
      <title>浮点数运算</title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/java/%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/java/%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97/</guid>
      <description>结论  Java中单精度和双精度采用IEEE 754表示，能有效运算的范围大致是小数点后7位和15位 如果Java中默认的float和double不能满足你的精度要求，可以用BigDecimal，理论上它的精度只受限制与机器内存 如果BigDecimal仍无法满足需求，例如是无限循环小数的运算，可考虑设计分数系统保证计算的精度  1. IEEE 754 精度上限 编程语言中的浮点数一般都是 32 位的单精度浮点数 float 和 64 位的双精度浮点数 double，部分语言会使用 float32 或者 float64 区分这两种不同精度的浮点数。想要使用有限的位数表示全部的实数是不可能的，不用说无限长度的小数和无理数，因为长度的限制，有限小数在浮点数中都无法精确的表示。
 单精度浮点数 float 总共包含 32 位，其中 1 位表示符号、8 位表示指数，最后 23 位表示小数； 双精度浮点数 double 总共包含 64 位，其中 1 位表示符号，11 位表示指数，最后 52 位表示小数；  我们以单精度浮点数 0.15625 为例:
通过上图中的公式 (sign * 2^{exp}* (1+fraction))可以将浮点数的二进制表示转换成十进制的小数。0.15625 虽然还可以用单精度的浮点数精确表示，但是 0.1 和 0.2 只能使用浮点数表示近似的值：
因为 0.2 和 0.1 只是指数稍有不同，所以上图中只展示了 0.1 对应的单精度浮点数，从上图的结果我们可以看出，0.1 和 0.2 在浮点数中只能用近似值来代替，精度十分有限，因为单精度浮点数的小数位为 23，双精度的小数位为 52，同时都隐式地包含首位的 1，所以它们的精度在十进制中分别是(log_{10}(2^{24})\approx 7.</description>
    </item>
    
    <item>
      <title>生产问题定位</title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/java/%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/java/%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D/</guid>
      <description>排除应用之外的影响因素： top(cpu)、free(内存)、df(磁盘)、dstat(网络流量)、pstack、vmstat、st1race(底层系统调用)
  top 定位CPU 最高的进程
  top -Hp pid 定位使用 CPU 最高的线程（或者 ps -mp pid -o THREAD,tid,time）
  printf &#39;0x%x&#39; tid 线程 id 转化 16 进制
  jstack pid | grep tid 找到线程堆栈
5.1 gc线程（如下是查看gc情况的几种方式）
    查看gc 日志
  jstat -gcutil 进程号 统计间隔毫秒 统计次数（缺省代表一致统计
  如果所在公司有对应用进行监控的组件当然更方便（比如Prometheus + Grafana）
5.2 业务线程
  关注线程堆栈的lock字段
  jstack -l pid | grep BLOCKED 查看阻塞态线程堆栈</description>
    </item>
    
    <item>
      <title>线程安全的单例的几种实现方法</title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/java/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%8D%95%E4%BE%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/java/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%8D%95%E4%BE%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/</guid>
      <description>1. 使用synchronized 饱汉：双重检查锁定、饿汉、静态内部类、枚举 都属于利用synchronized同步原理实现
1.1 饱汉：双重检查锁定（double-checked locking） public class SingleTon { // 静态实例变量加上volatile  private static volatile SingleTon instance; // 私有化构造函数  private SingleTon() {} // 双重检查锁  public static SingleTon getInstance() { if (instance == null) { synchronized(SingleTon.class){ if(instance == null){ instance = new SingleTon(); } } } return instance; } 1.2 饿汉 public class Singleton { private static Singleton instance = new Singleton(); private Singleton() { } public static Singleton getInstance() { return instance; } } 1.</description>
    </item>
    
    <item>
      <title>线程状态</title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/java/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/java/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/</guid>
      <description>Linux线程的状态与调度 Java线程的6种状态及切换 参考 Linux线程的状态与调度 </description>
    </item>
    
    <item>
      <title>脚手架</title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/java/%E8%84%9A%E6%89%8B%E6%9E%B6/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/java/%E8%84%9A%E6%89%8B%E6%9E%B6/</guid>
      <description>1. 什么是java脚手架 其实就是java工程模板，你可以把一些通用的组件抽象成一个模板，下次开发的时候基于这个模板开发，避免重复造轮子。像apache默认就提供了很多模板（archetype）
2. 创建archetype 假如你已经有了一个maven项目，想给该项目创建一个archetype模板。你需要cd 到项目根目录下执行(pom.xml同级目录)。
mvn archetype:create-from-project 执行完后，生成的target类似这样：
3. 生成archetype模板 先cd target/generated-sources/archetype/ 然后执行：
mvn install 执行成功后，执行crawl命令：
mvn archetype:crawl 在本地仓库的根目录生成archetype-catalog.xml骨架配置文件:
来看一看它里面的内容:
4. 使用archetype模板 执行mvn archetype:generate -DarchetypeCatalog=local从本地archetype模板中创建项目。
mvn archetype:generate -DarchetypeCatalog=local 然后会让你选择模板序号和groupId artifactId version和package信息：
至此，项目创建成功!
当然，也可以使用IDEA来帮我们用图形界面使用archetype模板创建项目：
这里的信息根据archetype-catalog.xml中的填写，如果是本地导入Repository可以不填或者填&amp;rsquo;local&#39;。既然提到本地，那么自然可以想到，可以将脚手架发布到nexus私服。发布到私服可以参看这里：https://www.cnblogs.com/woshimrf/p/maven-artifact-demo.html</description>
    </item>
    
    <item>
      <title>锁</title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/java/%E9%94%81/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/java/%E9%94%81/</guid>
      <description>阿里面试，问了我乐观锁、悲观锁、AQS、sync和Lock，这个回答让我拿了offer 阿里面试官：说一下公平锁和非公平锁的区别？ </description>
    </item>
    
    <item>
      <title>零拷贝</title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/java/%E9%9B%B6%E6%8B%B7%E8%B4%9D/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/java/%E9%9B%B6%E6%8B%B7%E8%B4%9D/</guid>
      <description>1. 简介 零拷贝的“零”是指用户态和内核态间copy数据的次数为零。
传统的数据copy（文件到文件、client到server等）涉及到四次用户态内核态切换、四次copy。四次copy中，两次在用户态和内核态间copy需要CPU参与、两次在内核态与IO设备间copy为DMA方式不需要CPU参与。零拷贝避免了用户态和内核态间的copy、减少了Java零拷贝机制解析核态间的切换。
 DMA(Direct Memory Access，直接内存存取) 是所有现代电脑的重要特色，它允许不同速度的硬件装置来沟通，而不需要依赖于CPU 的大量中断负载。 DMA控制器，接管了数据读写请求，减少CPU的负担。这样一来，CPU能高效工作了。 现代硬盘基本都支持DMA。
 使用Zero Copy前后对比：
使用前：
使用后：
Linux支持的(常见)零拷贝 mmap内存映射` `sendfile` `Sendfile With DMA Scatter/Gather Copy` `splice 无论是传统IO方式，还是引入零拷贝之后，2次DMA copy 是都少不了的。因为两次DMA都是依赖硬件完成的。
实际上，零拷贝时有广义和狭义之分的。 广义零拷贝： 能减少拷贝次数，减少不必要的数据拷贝，就算作“零拷贝”。 这是目前，对零拷贝最为广泛的定义，我们需要知道的是，这是广义上的零拷贝，并不是操作系统 意义上的零拷贝。
Java零拷贝机制解析 Linux提供的领拷贝技术 Java并不是全支持，支持2种(内存映射mmap、sendfile)；
NIO提供的内存映射：MappedByteBuffer
NIO提供的sendfile：FileChannel.transferTo() FileChannel.transferFrom()
参考链接： Java中的零拷贝 Java零拷贝 </description>
    </item>
    
  </channel>
</rss>
