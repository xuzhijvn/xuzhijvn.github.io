<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>JVM on 🇨🇳🇨🇳🇨🇳🇨🇳🇨🇳</title>
    <link>https://xuzhijvn.github.io/zh-cn/tags/jvm/</link>
    <description>Recent content in JVM on 🇨🇳🇨🇳🇨🇳🇨🇳🇨🇳</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>Copyright © 2016-{year} Razon Yang. All Rights Reserved.</copyright>
    <lastBuildDate>Sun, 05 Dec 2021 11:48:50 +0800</lastBuildDate><atom:link href="https://xuzhijvn.github.io/zh-cn/tags/jvm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>JVM OOM</title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/code/java/jvm-oom/</link>
      <pubDate>Sun, 05 Dec 2021 11:48:50 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/code/java/jvm-oom/</guid>
      <description></description>
    </item>
    
    <item>
      <title>JVM锁优化</title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/code/java/jvm%E9%94%81%E4%BC%98%E5%8C%96/</link>
      <pubDate>Thu, 09 Sep 2021 10:46:14 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/code/java/jvm%E9%94%81%E4%BC%98%E5%8C%96/</guid>
      <description></description>
    </item>
    
    <item>
      <title>JVM内存模型</title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/code/java/jvm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Mon, 06 Sep 2021 00:13:21 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/code/java/jvm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</guid>
      <description></description>
    </item>
    
    <item>
      <title>JVM类加载器</title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/code/java/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</link>
      <pubDate>Mon, 06 Sep 2021 00:13:02 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/code/java/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>JVM架构</title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/code/java/jvm%E6%9E%B6%E6%9E%84/</link>
      <pubDate>Mon, 06 Sep 2021 00:10:01 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/code/java/jvm%E6%9E%B6%E6%9E%84/</guid>
      <description></description>
    </item>
    
    <item>
      <title>JVM垃圾回收</title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/code/java/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</link>
      <pubDate>Sun, 05 Sep 2021 23:48:46 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/code/java/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</guid>
      <description></description>
    </item>
    
    <item>
      <title>JIT即时编译</title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/code/java/jit%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/code/java/jit%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91/</guid>
      <description>JIT (just-in-time compilation) 是指程序在运行过程中对热点代码进行编译的过程，编译后的机器码存入CodeCache，下次再遇到这段代码，就会从CodeCache中读取机器码，直接执行，以此来提升程序运行的性能。
有的JVM全程都是JIT编译运行，例如：JRockit；有的JVM是解释器 + JIT运行，例如：HotSpot, J9（也支持AOT）；有的JVM没有解释器，只支持AOT+JIT或者纯AOT，例如：Excelsior JET
以HotSpot JVM举例，JIT还可以分为C1, C2等。C1编译快，执行效率低；C2编译慢，效率高。可以通过 -XX:+TieredCompilation 开启分层编译，对热点代码先C1编译以尽快进入到编译执行模式；随着应用继续运行，收集到足够多的指标后，再进行C2编译，以期获得最好的执行效率。
JIT在编译过程中会采用一些优化手段，包括：公共子表达式消除、数组范围检查消除、方法内联、逃逸分析（目的是栈上分配、同步消除、标量替换、循环变型、窥孔优化与寄存器分配）
1. 编译器与解释器 不做特别说明的话，我们讲的，
编译器：程序运行前将其编译成机器码的程序
解释器：程序运作中逐行解释源码得到结果的程序
 特别注意的是，解释器也是一个程序，输入源码，输出结果，并没有显示的将源码转换成机器码的过程 解释器与 JIT  无论是编译器还是解释器，从 源码 到结果都需要将源码经过：词法分析 -&amp;gt; 语法分析 -&amp;gt; 语义分析 处理，
一个比较简单的编译器的处理步骤看起来：
编译流程： 源码 [字符流] - 词法分析 -&amp;gt; 单词（token）流 - 语法分析 -&amp;gt; 语法树 / 抽象语法树 - 语义分析 -&amp;gt; 标注了属性的抽象语法树 - 代码生成 -&amp;gt; 目标代码 执行流程： 目标代码 - 操作系统/硬件 -&amp;gt; 执行结果 狭义的解释器处理步骤看起来：
解释执行流程： 源码 [字符流] - 需要做词法分析+语法分析+类型检查的字符流解释器 -&amp;gt; 执行结果  特别注意的是，解释器真正的输入往往并直接是源码，使用解释器实现的编程语言实现里，通常：</description>
    </item>
    
    <item>
      <title>OOM实战</title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/code/java/oom%E5%AE%9E%E6%88%98/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/code/java/oom%E5%AE%9E%E6%88%98/</guid>
      <description>《深入理解Java虚拟机》中将OOM划分为: Java堆溢出、虚拟机栈和本地方法栈溢出、方法区和运行时常量池溢出、本机直接内存溢出
1. Java堆溢出 /** * JDK1.6/JDK1.8 * * Java堆内存溢出异常测试 * * VM Args: -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError * * @author xuzhijun.online * @date 2019年4月22日 */ public class HeapOOM { static class OOMObject{ } public static void main(String[] args) { List&amp;lt;OOMObject&amp;gt; list = new ArrayList&amp;lt;OOMObject&amp;gt;(); while(true) { list.add(new OOMObject()); } } } 运行结果：
java.lang.OutOfMemoryError: Java heap space Dumping heap to java_pid3404.hprof ... Heap dump file created [22045981 bytes in 0.663 secs] 处理方法：</description>
    </item>
    
    <item>
      <title>生产问题定位</title>
      <link>https://xuzhijvn.github.io/zh-cn/posts/code/java/%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/zh-cn/posts/code/java/%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D/</guid>
      <description>排除应用之外的影响因素： top(cpu)、free(内存)、df(磁盘)、dstat(网络流量)、pstack、vmstat、st1race(底层系统调用)
  top 定位CPU 最高的进程
  top -Hp pid 定位使用 CPU 最高的线程（或者 ps -mp pid -o THREAD,tid,time）
  printf &#39;0x%x&#39; tid 线程 id 转化 16 进制
  jstack pid | grep tid 找到线程堆栈
5.1 gc线程（如下是查看gc情况的几种方式）
👉🏿 查看gc 日志
👉🏿 jstat -gcutil 进程号 统计间隔毫秒 统计次数（缺省代表一次统计）
👉🏿 如果所在公司有对应用进行监控的组件当然更方便（比如Prometheus + Grafana）
 结合内存dump日志分析：
  哪些对象导致的内存溢出导致频繁gc（尤其是full gc）
  如果不是内存溢出导致频繁gc，也可能是代码或者第三方依赖的包中有显示的System.gc()调用，此时可以通过添加 -XX:+DisableExplicitGC来禁用JVM对显示GC的响应。
在分配堆外内存的时候，内存不足时会显示的调用System.gc()，如果显示gc被禁用，则可能会导致堆外内存溢出，所以堆外内存的回收最好就不要依赖jvm，主动回收吧。
   5.2 业务线程</description>
    </item>
    
  </channel>
</rss>
