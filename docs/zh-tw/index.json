[{"categories":["Server"],"content":"最近筆者將博客主題更換為 Bootstrap\r，為了以後方便增添和區分繁體中文，打算將以前簡體中文路徑由 /zh/ 改為 /zh-cn/。而筆者使用的是 Caddy 2 服務器，正好相關教程太少，順便寫一篇教程，以記錄和方便其他有類似需求的小夥伴們。\n配置 廢話少說，直接上碼。\n@zh { path_regexp zh ^/zh/(.*)$ } redir @zh /zh-cn/{http.regexp.zh.1} 301 配置十分簡單，只用到了 path_regexp\r和 redir\r指令。\n說明  首先定義了一個名為 @zh 的命名匹配器，用於 redir 指令。 path_regexp 指定了正則的名稱 zh，其可以通過 {http.regexp.zh.*} 來獲取相關數據。 ^/zh/(.*)$ 正則匹配以 /zh/ 路徑的其餘部分為 {http.regexp.zh.1}。 最後 redir 到新的路徑 /zh-cn/ 即可。 ","date":"2020-11-29","permalink":"https://razonyang.com/zh-tw/posts/caddy/redirect-from-old-path-to-new-path/","series":null,"tags":["Caddy"],"title":"Caddy 2 重定向舊路徑到新路徑"},{"categories":["Programing"],"content":"Bootstrap 導航欄下拉菜單移除倒三角圖標。\n移除 dropdown-toggle class 即可。\n","date":"2020-10-17","permalink":"https://razonyang.com/zh-tw/posts/bootstrap/navbar-dropdown-remove-arrow/","series":null,"tags":["Bootstrap"],"title":"Bootstrap 導航欄下拉菜單移除倒三角圖標"},{"categories":["Programing"],"content":"自定義 Go 模塊的導入路徑有一個主要的好處，當你打算更換代碼的託管服務器，比如 GitHub 換到 GitLab、Gitee 時，你不需要更改包的導入路徑。而 gopkgs\r正是這樣一個 HTTP 服務，可以讓你自定義 Go 庫的導入路徑。\n gopkgs.net 是筆者為了自身業務搭建的，大家可以免費試用。\n 先決條件  域名  步驟 本文以 clevergo.tech 作為例子，其代碼託管在 GitHub，比如：\n   Import Path Repository     clevergo.tech/clevergo https://github.com/clevergo/clevergo\r   clevergo.tech/captchas https://github.com/clevergo/captchas\r   \u0026hellip;      註冊賬號並登錄後臺。 然後在後臺添加域名，並添加相應的 CNAME 記錄到 gopkgs.net，然後驗證域名所有權。 接著添加 Go 包，填寫相應的信息即可。  驗證 驗證時，我們需要使用 go get -u -v，比如：\n$ go get -u -v clevergo.tech/clevergo get \u0026#34;clevergo.tech/clevergo\u0026#34;: found meta tag get.metaImport{Prefix:\u0026#34;clevergo.tech/clevergo\u0026#34;, VCS:\u0026#34;git\u0026#34;, RepoRoot:\u0026#34;https://github.com/clevergo/clevergo\u0026#34;} at //clevergo.tech/clevergo?go-get=1 clevergo.tech/clevergo (download) get \u0026#34;clevergo.tech/log\u0026#34;: found meta tag get.metaImport{Prefix:\u0026#34;clevergo.tech/log\u0026#34;, VCS:\u0026#34;git\u0026#34;, RepoRoot:\u0026#34;https://github.com/clevergo/log\u0026#34;} at //clevergo.tech/log?go-get=1 clevergo.tech/log (download) clevergo.tech/log clevergo.tech/clevergo 如上所示，解析的 META 標籤正確，即表示成功。\n","date":"2020-10-05","permalink":"https://razonyang.com/zh-tw/posts/go/custom-import-path-via-gopkgs/","series":null,"tags":["Go","gopkgs"],"title":"利用 gopkgs 自定義 Go 庫的導入路徑"},{"categories":["Linux"],"content":"Arch Linux 下 ZSH 的安裝和使用教程。\n安裝 # pacman -S zsh ","date":"2020-10-04","permalink":"https://razonyang.com/zh-tw/posts/archlinux/zsh/","series":null,"tags":["Arch Linux","zsh"],"title":"Arch Linux 安裝 ZSH"},{"categories":["Linux"],"content":"SELinux Apache proxy error permission denied 的解決方法。\n在啟動 Apache 的時候出現以下類似錯誤時：\n [proxy:error] [pid 28961:tid 139839546509056] (13)Permission denied: AH00957: HTTP: attempt to connect to 198.143.164.251:80 (*) failed.\n 執行以下命令，並重啟即可：\n# /usr/sbin/setsebool -P httpd_can_network_connect 1 ","date":"2020-07-06","permalink":"https://razonyang.com/zh-tw/posts/selinux/apache-proxy-error-permission-denied/","series":null,"tags":["SELinux","Apache","httpd"],"title":"SELinux Apache proxy error permission denied"},{"categories":["Linux"],"content":"SELinux is preventing httpd from name_bind access on the tcp_socket port 的解決方法。\nApache 遇到以下類似錯誤時：\n SELinux is preventing /usr/sbin/httpd from name_bind access on the tcp_socket port 4040\n 可以通過以下命令解決：\n# semanage port -a -t httpd_port_t -p tcp [port]  [port] 改為對應的端口即可，如 4040。 ","date":"2020-07-06","permalink":"https://razonyang.com/zh-tw/posts/selinux/prevents-httpd-from-name-bind-access-on-the-tcp-socket-port/","series":null,"tags":["Apache","httpd","SELinux"],"title":"SELinux is preventing httpd from name_bind access on the tcp_socket port"},{"categories":["Linux"],"content":"一般為了在一定程度上避免他人暴力破解密碼，我都會修改 sshd 的默認端口。\n 當然更安全的做法是禁止密碼登錄，利用密鑰進行登錄。\n 修改配置 # vim /etc/ssh/sshd_config Port 23333 重啟服務 # systemctl restart sshd SELinux 如果安裝了 SELinux，重啟服務可能會出現以下錯誤：\n SELinux is preventing /usr/sbin/sshd from name_bind access on the tcp_socket port 23333.\n 這是因為 SELinux 默認只允許 sshd 監聽 22 端口：\n# semanage port -l | grep ssh ssh_port_t tcp 22 為 sshd 添加相應的端口並重新啟動服務即可：\n# semanage port -a -t ssh_port_t -p tcp 23333 # semanage port -l | grep ssh ssh_port_t tcp 22, 23333 # systemctl restart sshd ","date":"2020-07-03","permalink":"https://razonyang.com/zh-tw/posts/centos/change-sshd-port/","series":null,"tags":["CentOS","SELinux","sshd"],"title":"CentOS 修改 sshd 端口"},{"categories":["Linux"],"content":"V2ray Desktop 是一個跨平臺的 V2ray 的圖形客戶端，在 Arch Linux 下可以通過以下命令安裝 AUR 包 v2ray-desktop：\n$ yay -S v2ray-desktop  yay 是 AUR 助手，改為你的 AUR 助手命令即可。\n ","date":"2020-06-11","permalink":"https://razonyang.com/zh-tw/posts/archlinux/v2ray-desktop/","series":null,"tags":["Arch Linux","V2ray","V2ray Desktop"],"title":"Arch Linux 安裝 V2ray Desktop"},{"categories":["Linux"],"content":"在 4K 顯示屏下，SDDM 界面顯示得非常小，我們可以通過 xrandr 命令解決。\n列出顯示器：\n$ xrandr --listmonitors Monitors: 2 0: +*HDMI-0 1920/700x1080/390+0+0 HDMI-0 1: +eDP-1-1 1920/344x1080/193+1920+0 eDP-1-1 其中 eDP-1-1 是筆者筆記本的內置顯示器，DMI-0 則是的外接顯示器。\n接著添加以下命令到 /usr/share/sddm/scripts/Xsetup 即可：\n$ vim /usr/share/sddm/scripts/Xsetup xrandr --output eDP-1-1 --mode 1920x1080  output 為顯示器名稱。 mode 為分辨率。 ","date":"2020-06-10","permalink":"https://razonyang.com/zh-tw/posts/sddm/resolution/","series":null,"tags":["SDDM","4K"],"title":"SDDM 4K 屏幕設置 1920×1080 分辨率"},{"categories":["Programing"],"content":"Flarum Nginx 配置示例。\nserver { server_name forum.local; root /path-to-flarum/public; index index.php; include /path-to-flarum/.nginx.conf; location ~ \\.php$ { fastcgi_pass php; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; } } ","date":"2020-04-04","permalink":"https://razonyang.com/zh-tw/posts/flarum/nginx-config/","series":null,"tags":["Flarum","Nginx"],"title":"Flarum Nginx 配置"},{"categories":["Programing"],"content":"Go 編寫優雅的構造函數。\n假設有一個名為 ViewManager 的結構體如下：\ntype ViewManager struct { fs http.FileSystem // 文件系統  suffix string // 視圖文件的後綴  cache bool // 是否開啟緩存 } func New(fs http.FileSystem) *ViewManager { return \u0026amp;ViewManager{ fs: fs, cache: true, suffix: \u0026#34;.tmpl\u0026#34;, } } 其所有成員都是不可寫的，在我們需要創建不同 suffix、cache 的實例時，我們可以輕易地通過新增構造函數來實現，如 NewSuffix(fs http.FileSystem, suffix string)、NewCache(fs http.FileSystem, cache bool)，但是這樣看起來繁瑣不美觀。其實我們可以通過一個構造函數來實現。\n配置結構 第一種很簡單，定義一個配置結構，然後傳入到構造函數即可。\ntype Config struct { Suffix string Cache bool } func New(fs http.FileSystem, cfg Config) *ViewManager { m := \u0026amp;ViewManager{ fs: fs, cache: cfg.Cache, suffix: \u0026#34;.tmpl\u0026#34;, } if cfg.Suffix != \u0026#34;\u0026#34; { m.suffix = suffix } return m } 配置函數 配置函數和配置結構類似，只是利用函數的方式進行設置：\ntype Option func(*ViewManager) func Suffix(v string) Option { return func(m *ViewManager) { m.suffix = v } } func Cache(v bool) Option { return func(m *ViewManager) { m.cache = v } } func New(fs http.FileSystem, opts ... Option) *ViewManager { m := \u0026amp;ViewManager{ fs: fs, cache: true, suffix: \u0026#34;.tmpl\u0026#34;, } for _, f := range opts { f(m) } return m } 區別 兩種方式很常見，在標準庫和第三方庫都可以看到，不過筆者更喜歡後者，無需在構造函數進行過多的判斷，編寫單元測試也更容易。\n","date":"2020-03-12","permalink":"https://razonyang.com/zh-tw/posts/go/better-constructor/","series":null,"tags":["Go"],"title":"Go 編寫優雅的構造函數"},{"categories":["Programing"],"content":"如果你的 WordPress 所在服務器在境內，應該是無法在線自動更新的，這是因為境內發出的請求，WordPress 都會返回 429 Too Many Requests。本篇介紹如何通過代理解決。\n步驟  一臺境外的服務器。 設置正向代理服務，可以參考 Apache 正向代理配置\r。 修改 WordPress 配置。   題外話，Nginx 似乎並不支持正向代理 HTTPS 請求（CONNECT 會返回 400 狀態碼）。\n 修改配置 本文假定你已經正確設置了正向代理的境外服務器。\n修改 wp-config.php，添加以下常量：\ndefine(\u0026#39;WP_PROXY_HOST\u0026#39;, \u0026#39;wp.errlogs.com\u0026#39;); // 代理主機地址，可以為 IP。 define(\u0026#39;WP_PROXY_PORT\u0026#39;, \u0026#39;4040\u0026#39;); // 代理主機端口。  // Basic Auth 的帳號和密碼，可選。 // define(\u0026#39;WP_PROXY_USERNAME\u0026#39;, \u0026#39;foo\u0026#39;); // define(\u0026#39;WP_PROXY_PASSWORD\u0026#39;, \u0026#39;bar\u0026#39;);  // 跳過代理的主機列表，可選。 // define(\u0026#39;WP_PROXY_BYPASS_HOSTS\u0026#39;, \u0026#39;127.0.0.1, localhost\u0026#39;); ","date":"2020-03-12","permalink":"https://razonyang.com/zh-tw/posts/wordpress/proxy/","series":null,"tags":["Proxy","WordPress"],"title":"WordPress 設置代理"},{"categories":["Programing"],"content":"Apache 正向代理配置示例。\n假定代理的端口為 4040：\nListen 4040 \u0026lt;VirtualHost *:4040\u0026gt; ProxyRequests On ProxyVia On \u0026lt;Proxy \u0026#34;*\u0026#34;\u0026gt; Deny from all Allow from 129.204.189.159 \u0026lt;/Proxy\u0026gt; \u0026lt;/VirtualHost\u0026gt; Deny from all 和 Allow from IP 是為了防止他人濫用代理服務（限定某 IP 可用），你也可以設置其他規則，比如 Basic Auth。\n","date":"2020-03-12","permalink":"https://razonyang.com/zh-tw/posts/apache/forward-proxy/","series":null,"tags":["Apache","Proxy"],"title":"Apache 正向代理配置"},{"categories":["Linux"],"content":"Linux 利用 ss 查看進程監聽的端口。\n$ sudo ss -tulpn | grep 8080 tcp LISTEN 0 4096 127.0.0.1:8080 0.0.0.0:* users:((\u0026#34;main\u0026#34;,pid=2405713,fd=11)) 其中 pid 是進程 ID。\n","date":"2020-03-11","permalink":"https://razonyang.com/zh-tw/posts/linux/ss-check-process-listen-port/","series":null,"tags":["ss"],"title":"Linux 利用 ss 查看進程監聽的端口"},{"categories":["Linux"],"content":"Linux 清理 DNS 緩存方法。\n$ sudo systemctl restart nscd  nscd: name service cache daemon.\n","date":"2020-03-10","permalink":"https://razonyang.com/zh-tw/posts/linux/clear-dns-cache/","series":null,"tags":["DNS","nscd"],"title":"Linux 清理 DNS 緩存"},{"categories":["Linux"],"content":"A stop job is running for MariaDB database service(Waiting for page_cleaner) 原因及解決方法。\n在關機或重啟的時候發現：\n A stop job is running for MariaDB database service.\n 居然需要耗時幾十分鐘，強制關機重啟後，利用以下命令檢查日誌：\n$ journalctl -u mariadb.service Feb 25 14:37:57 archlinux mysqld[580]: 2020-02-25 14:37:57 0 [Note] InnoDB: Waiting for page_cleaner to finish flushing of buffer pool Feb 25 14:38:57 archlinux mysqld[580]: 2020-02-25 14:38:57 0 [Note] InnoDB: Waiting for page_cleaner to finish flushing of buffer pool Feb 25 14:39:57 archlinux mysqld[580]: 2020-02-25 14:39:57 0 [Note] InnoDB: Waiting for page_cleaner to finish flushing of buffer pool Feb 25 14:40:58 archlinux mysqld[580]: 2020-02-25 14:40:58 0 [Note] InnoDB: Waiting for page_cleaner to finish flushing of buffer pool ... 解決 經過一番搜索，可以通過以下命令解決：\n$ timedatectl set-local-rtc 0 相關鏈接： How to fix MariaDB when it gets stuck during shutdown (Waiting for page_cleaner)?\r","date":"2020-02-25","permalink":"https://razonyang.com/zh-tw/posts/archlinux/a-stop-job-is-running-for-mariadb-database-service-waiting-for-page-cleaner/","series":null,"tags":["Arch Linux","MariaDB"],"title":"A stop job is running for MariaDB database service(Waiting for page_cleaner)"},{"categories":["Programing"],"content":"編寫一個 SQL 查詢，獲取 Employee 表中第 n 高的薪水（Salary）。\n   Id Salary     1 100   2 200   3 300    例如上述 Employee 表，n = 2 時，應返回第二高的薪水 200。如果不存在第 n 高的薪水，那麼查詢應返回 null。\n   getNthHighestSalary(2)     200    解答 CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT BEGIN # offset 和 N 相差 1 DECLARE i INT; SET i = N-1; RETURN ( SELECT ( SELECT DISTINCT Salary FROM Employee ORDER BY Salary DESC LIMIT 1 OFFSET i ) ); END 原題 來源：力扣（LeetCode）\n鏈接：https://leetcode-cn.com/problems/nth-highest-salary\r","date":"2020-02-22","permalink":"https://razonyang.com/zh-tw/posts/leetcode/database/nth-highest-salary/","series":null,"tags":["LeetCode","MySQL"],"title":"LeetCode 數據庫面試題 – 第N高的薪水"},{"categories":["Linux"],"content":"在 Linux 或者 macOS 下，我們可以通過 dd 刻錄系統啟動盤到U盤裡。\n首先需要準備一個系統鏡像和一個的 U 盤。\n接著查看U盤的設備標識：\n$ sudo fdisk -l 比如我們這裡獲得的U盤標識為**/dev/sdX**。\n最後使用 dd 刻錄即可：\n$ sudo dd if=/path/to/system.iso of=/dev/sdX status=progress  if：input file，系統鏡像的路徑。 of：output file，目標設備，/dev/sdX 為上一步驟獲得的U盤的標識。 status：設置為 progress 可以顯示寫入狀態。 ","date":"2020-02-19","permalink":"https://razonyang.com/zh-tw/posts/linux/dd-create-bootable-flash-driver/","series":null,"tags":["dd"],"title":"利用 dd 命令刻錄 U 盤系統啟動盤"},{"categories":["Programing"],"content":"Employee 表包含所有員工信息，每個員工有其對應的 Id, salary 和 department Id。\n編寫一個 SQL 查詢，找出每個部門工資最高的員工。例如，根據上述給定的表格，Max 在 IT 部門有最高工資，Henry 在 Sales 部門有最高工資。\n   Id Name Salary DepartmentId     1 Joe 70000 1   2 Henry 80000 2   3 Sam 60000 2   4 Max 90000 1    Department 表包含公司所有部門的信息。\n   Id Name     1 IT   2 Sales       Department Employee Salary     IT Max 90000   Sales Henry 80000    解答  子查詢獲取每個部門最高的工資。 再使用 WHERE IN 篩選。  SELECT d.Name as Department, e.Name as Employee, e.Salary as Salary FROM Employee e LEFT JOIN Department d ON e.DepartmentId = d.Id WHERE (e.DepartmentId, e.Salary) IN ( SELECT DepartmentId, MAX(Salary) FROM Employee GROUP BY DepartmentId ) AND d.Id IS NOT NULL ORDER BY e.Id  ORDER BY e.Id 是無關緊要的，只是結果集順序問題。\n 原題 來源：力扣（LeetCode）\n鏈接：https://leetcode-cn.com/problems/department-highest-salary\r","date":"2020-02-10","permalink":"https://razonyang.com/zh-tw/posts/leetcode/database/department-highest-salary/","series":null,"tags":["LeetCode","MySQL"],"title":"LeetCode 數據庫面試題 – 部門工資最高的員工"},{"categories":["Programing"],"content":"編寫一個 SQL 查詢，查找所有至少連續出現三次的數字。\n   Id Num     1 1   2 1   3 1   4 2   5 1   6 2   7 2    例如，給定上面的 Logs 表， 1 是唯一連續出現至少三次的數字。\n 假設 Id 是連續的。\n    ConsecutiveNums     1    解答 左連接自身獲得前兩條記錄，判斷 Num 是否一樣，最後 DISTINCT 去掉重複的 Num 即可。\nSELECT DISTINCT l1.Num AS ConsecutiveNums FROM Logs l1, Logs l2, Logs l3 WHERE l1.Id = l2.Id - 1 AND l2.Id = l3.Id - 1 AND l1.Num = l2.Num AND l2.Num = l3.Num ; 原題 來源：力扣（LeetCode）\n鏈接：https://leetcode-cn.com/problems/consecutive-numbers\r","date":"2020-02-07","permalink":"https://razonyang.com/zh-tw/posts/leetcode/database/consecutive-numbers/","series":null,"tags":["LeetCode","MySQL"],"title":"LeetCode 數據庫面試題 – 連續出現的數字"},{"categories":["Programing"],"content":"編寫一個 SQL 查詢來實現分數排名。如果兩個分數相同，則兩個分數排名（Rank）相同。請注意，平分後的下一個名次應該是下一個連續的整數值。換句話說，名次之間不應該有“間隔”。\n   Id Score     1 3.50   2 3.65   3 4.00   4 3.85   5 4.00   6 3.65    例如，根據上述給定的 Scores 表，你的查詢應該返回（按分數從高到低排列）：\n   Score Rank     4.00 1   4.00 1   3.85 2    3.65 3   3.65 3   3.50 4    分析 據題意，我們可以按 score 降序處理，然後進行以下判斷即可：\n 分數相同，排名不變 分數不同，排名 +1  解答 這裡引入兩個變量 @score, @rank 用來分別存儲上一條記錄的 score 和 rank，以便進行分數判斷和排名計算。\nSELECT Score, CAST(Rank AS SIGNED) as Rank FROM ( SELECT Score, @rank := IF(@score=Score, @rank, @rank + 1) as Rank, @score := Score FROM Scores s, (SELECT @score := null, @rank := 0) t ORDER BY Score DESC ) t 原題 來源：力扣（LeetCode）\n鏈接：https://leetcode-cn.com/problems/rank-scores\r","date":"2020-02-06","permalink":"https://razonyang.com/zh-tw/posts/leetcode/database/rank-scores/","series":null,"tags":["LeetCode","MySQL"],"title":"LeetCode 數據庫面試題 – 分數排名(Rank Scores)"},{"categories":["Programing"],"content":"V2ray 各平臺圖形客戶端推薦。\n   客戶端 平臺 說明     Qv2ray 跨平臺，Windows、Linux、macOS -   V2ray Desktop 跨平臺 -   V2rayNG Android -   Shadowrocket iOS -    相關資料  Arch Linux 安裝 V2ray 圖形客戶端 QV2ray\r Arch Linux 安裝 V2ray Desktop\r ","date":"2020-02-05","permalink":"https://razonyang.com/zh-tw/posts/v2ray/gui-clients/","series":null,"tags":["V2ray","QV2ray","V2ray Desktop","V2rayNG"],"title":"V2ray 各平臺圖形客戶端"},{"categories":["Programing"],"content":"PHP 中 ucfirst、lcfirst 和 ucwords 在 Go 語言中可以通過 strings 和 clevergo.tech/strutil 實現。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;clevergo.tech/strutil\u0026#34; ) func main() { // lcfirst  fmt.Println(strutil.InitialToLower(\u0026#34;HELLO\u0026#34;)) fmt.Println(strutil.InitialToLower(\u0026#34;你好\u0026#34;)) // ucfirst  fmt.Println(strutil.InitialToUpper(\u0026#34;world\u0026#34;)) fmt.Println(strutil.InitialToUpper(\u0026#34;世界\u0026#34;)) // ucwords  fmt.Println(strings.Title(\u0026#34;hello world\u0026#34;)) fmt.Println(strings.Title(\u0026#34;你好世界\u0026#34;)) } $ go run main.go hELLO 你好 World 世界 Hello World 你好世界 ","date":"2020-02-05","permalink":"https://razonyang.com/zh-tw/posts/go/ucfirst-lcfirst-ucwords/","series":null,"tags":["Go","PHP","lcfirst","ucfirst","ucwords"],"title":"Go 語言的 ucfirst、lcfirst 和 ucwords"},{"categories":["Programing"],"content":"Go 語言複製指針的值可以通過 *copy = *pointer 完成。\npackage main import \u0026#34;fmt\u0026#34; type person struct { name string gender int } func main() { foo := \u0026amp;person{\u0026#34;foo\u0026#34;, 1} bar := \u0026amp;person{} *bar = *foo fmt.Println(foo, bar) bar.name = \u0026#34;bar\u0026#34; fmt.Println(foo, bar) } $ go run main.go \u0026amp;{foo 1} \u0026amp;{foo 1} \u0026amp;{foo 1} \u0026amp;{bar 1} ","date":"2020-02-03","permalink":"https://razonyang.com/zh-tw/posts/go/copy-value-of-pointer/","series":null,"tags":["Go","Pointer"],"title":"Go 語言複製指針的值"},{"categories":["Programing"],"content":"給定兩個只包含小寫字母的字符串 s 和 t，其中字符串 t 是由字符串 s 亂序後，再在隨機位置添加一個字母而成，請找到該隨機添加的字母。\n例如：s = abcd, t = abcde, 其中 e 是隨機添加的字母。\n其實這個例子不夠明確，又比如 s = abcde, t = aedceb, 隨機添加的字母還是 e。\n原題 Given two strings s and t which consist of only lowercase letters.\nString t is generated by random shuffling string s and then add one more letter at a random position.\nFind the letter that was added in t.\nExample:\nInput:\ns = \u0026ldquo;abcd\u0026rdquo;\nt = \u0026ldquo;abcde\u0026rdquo;\nOutput:\ne\nExplanation:\n\u0026lsquo;e\u0026rsquo; is the letter that was added.\n分析  字符串 t 的字母總數比 s 多 1 字符串 t 的字母類別數和 s 相同或多 1  實現 實現一 依題意，用 map[byte]int 存儲字符串 s 中每個字母出現的次數，如果字符串 t 中某個字母不存在於 map 或出現次數過多，則該字母為隨機添加的字母。\n時間複雜度： O(n)\nfunc findTheDifferenceMap(s string, t string) byte { m := make(map[byte]int, len(s)) for i := 0; i \u0026lt; len(s); i++ { m[s[i]] += 1 } var b byte for i := 0; i \u0026lt; len(t); i++ { if count, ok := m[t[i]]; !ok || count \u0026lt;= 0 { b = t[i] break } else { m[t[i]] -= 1 } } return b } 實現二 可以利用 XOR 解決\nfunc findTheDifferenceXOR(s string, t string) byte { var b byte for i := 0; i \u0026lt; len(s); i++ { b ^= s[i] ^ t[i] } b ^= t[len(t)-1] return b } 性能 type pair struct { s string t string } var pairs = []pair{ {\u0026#34;abcd\u0026#34;, \u0026#34;abcde\u0026#34;}, {\u0026#34;abcd\u0026#34;, \u0026#34;aebcd\u0026#34;}, {\u0026#34;abcd\u0026#34;, \u0026#34;abecd\u0026#34;}, {\u0026#34;abcd\u0026#34;, \u0026#34;abced\u0026#34;}, } func BenchmarkFindTheDifferenceMap(b *testing.B) { var p pair for n := 0; n \u0026lt; b.N; n++ { p = pairs[n%len(pairs)] findTheDifferenceMap(p.s, p.t) } } func BenchmarkFindTheDifferenceXOR(b *testing.B) { var p pair for n := 0; n \u0026lt; b.N; n++ { p = pairs[n%len(pairs)] findTheDifferenceXOR(p.s, p.t) } } 結果：\n BenchmarkFindTheDifferenceMap-12 4990208 241 ns/op\nBenchmarkFindTheDifferenceXOR-12 90979062 12.7 ns/op\n 雖然測試不嚴謹，不過後者性能更高。\n","date":"2020-02-02","permalink":"https://razonyang.com/zh-tw/posts/leetcode/algorithm/find-the-difference/","series":null,"tags":["LeetCode","Go"],"title":"LeetCode 算法題 – Find The Difference"},{"categories":["Linux"],"content":"cURL 是一個數據傳輸的命令行腳本，筆者經常用於接口測試，本文簡單介紹下 cURL 的基本用法。\n用法 $ curl http://localhost 參數  -v Verbose 模式，可以看到請求和響應的頭部信息。 -X 指定請求方法，比如 POST： -XPOST -H 指定請求頭，比如 JSON：-HContent-Type: \u0026quot; application/json\u0026quot; -d 指定請求數據  例子 Basic Auth $ curl -u username:password http://localhost/auth 表單 $ curl -XPOST -d \u0026#34;username=foo\u0026amp;password=bar\u0026#34; http://localhost/login Multipart 表單 $ curl -XPOST -F \u0026#34;username=foo\u0026#34; -F \u0026#34;password=bar\u0026#34; http://localhost/login JSON $ curl -XPOST -H \u0026#34;Content-Type: application/json\u0026#34; -d \u0026#39;{\u0026#34;username\u0026#34;:\u0026#34;foo\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;bar\u0026#34;}\u0026#39; http://localhost/login XML $ curl -XPOST -H \u0026#34;Content-Type: application/xml\u0026#34; -d \u0026#39;\u0026lt;xml\u0026gt;\u0026lt;username\u0026gt;foo\u0026lt;/username\u0026gt;\u0026lt;password\u0026gt;bar\u0026lt;/password\u0026gt;\u0026lt;/xml\u0026gt;\u0026#39; http://localhost:1234/login ","date":"2020-01-30","permalink":"https://razonyang.com/zh-tw/posts/linux/curl/","series":null,"tags":["cURL"],"title":"cURL 基本用法"},{"categories":["Linux"],"content":"Shell 終端字符串換行方法。\n$ DATA=$\u0026#39;hello\\nworld\u0026#39; $ echo $DATA hello world ","date":"2020-01-30","permalink":"https://razonyang.com/zh-tw/posts/linux/shell-newline-in-string/","series":null,"tags":["Shell"],"title":"Shell 終端字符串換行"},{"categories":["Linux"],"content":"WSL Ubuntu 升級到 Go 1.13 教程。\n$ sudo add-apt-repository ppa:longsleep/golang-backports $ sudo apt-get update $ sudo apt-get install golang-go ","date":"2020-01-28","permalink":"https://razonyang.com/zh-tw/posts/wsl/ubuntu-upgrade-go113/","series":null,"tags":["Ubuntu","WSL","Go"],"title":"WSL Ubuntu 升級到 Go 1.13"},{"categories":["Programing"],"content":"博客換域名後，Google Adsense 不顯示，瀏覽器控制檯出現以下錯誤：\n Failed to load resource: the server responded with a status of 403\n 這個是因為需要將新域名添加到 Adsense，審核過後就可以顯示了。審核一般幾天內就能完成，特殊情況最長兩週時間，不過筆者新域名當天就通過了，耐心等待就好。\n","date":"2020-01-17","permalink":"https://razonyang.com/zh-tw/posts/google-adsense/unauthorized/","series":null,"tags":["Google Adsense"],"title":"Google Adsense Failed to load resource: the server responded with a status of 403"},{"categories":["Linux"],"content":"Arch Linux ZSH 安裝自動補全/命令提示插件的安裝和使用。\n安裝 # pacman -S zsh-autosuggestions 配置 $ vim ~/.zshrc source /usr/share/zsh/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh ","date":"2020-01-12","permalink":"https://razonyang.com/zh-tw/posts/archlinux/zsh-autosuggestions/","series":null,"tags":["Arch Linux","ZSH"],"title":"Arch Linux ZSH 安裝自動補全/命令提示插件"},{"categories":["Linux"],"content":"筆者筆記本（ThinkPad X1 Extreme）是雙系統引導，昨天更新了下版本 1.25 的 BIOS ，然後發現我的 GRUB 引導不見了\u0026hellip;無論如何都是引導 Windows，筆者嘗試了以下方法：\n chroot 到 Linux，重建 GRUB：grub-install 和 grub-mkconfig 關閉 Windows 快速啟動，bcdedit /set \u0026quot;{bootmgr}\u0026quot; path \u0026quot;\\EFI\\Arch\\grubx64.efi\u0026quot;  無果，在 BIOS Boot 或 Boot Menu 中都沒有 GRUB 的蹤影。\n解決 有些資料說，替換掉 Windows 的 /EFI/Microsoft/Boot/bootmgfw.efi 為 GRUB 的即可，以 Arch Linux 為例：\n# grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=Arch # ls /boot/EFI/Arch/ grubx64.efi 這裡安裝了 GRUB，在替換前需要備份/EFI/Microsoft/Boot/bootmgfw.efi：\n# mv /boot/EFI/Microsoft/Boot/bootmgfw.efi /boot/EFI/Microsoft/Boot/bootmgfw.efi.ori # cp /boot/EFI/Arch/grubx64.efi /boot/EFI/Microsoft/Boot/bootmgfw.efi 緊接著生成配置：\n# grub-mkconfig -o /boot/grub/grub.cfg Generating grub configuration file ... Found linux image: /boot/vmlinuz-linux Found initrd image: /boot/initramfs-linux.img Found fallback initrd image(s) in /boot: initramfs-linux-fallback.img Found Windows Boot Manager on /dev/nvme0n1p2@/EFI/Microsoft/Boot/bootmgfw.efi done 這裡雖然檢測到了 Windows 引導項，但是因為上面我們替換了原本的 bootmgfw.efi，這裡的 Windows 引導並沒有真正起效，我們還需要編輯 Windows 的引導項，將其值改成 bootmgfw.efi.ori:\n# sed -i 's/bootmgfw.efi$/bootmgfw.efi.ori/g' /boot/grub/grub.cfg\r 至此，大公告成。雖然怪怪的，但是懶得去服務站，能用就好。\n相關鏈接  Dual boot with Windows\r ","date":"2020-01-10","permalink":"https://razonyang.com/zh-tw/posts/linux/grub-was-gone-after-bios-update/","series":null,"tags":["Arch Linux","GRUB","BIOS","GRUB"],"title":"雙系統更新 BIOS 後，GRUB 引導項消失的解決方法"},{"categories":["Programing"],"content":"MySQL 創建用戶並授權教程。\n創建用戶 CREATE USER \u0026#39;user\u0026#39;@\u0026#39;host\u0026#39; IDENTIFIED BY \u0026#39;password\u0026#39; 比如創建一個密碼為 foobar 的本地用戶 razon：\nCREATE USER \u0026#39;razon\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED BY \u0026#39;foobar\u0026#39; 授權 GRANT privileges ON database.table TO \u0026#39;user\u0026#39;@\u0026#39;host\u0026#39;  database.table 指定數據庫表，database.* 指整個數據庫 privileges 根據 database.table 的不同有不一樣的選項，詳情請戳 MySQL Privileges\r  一般的，我們為每個數據庫新增一個管理帳號，比如將數據庫 foobar 的所有權限授予 razon：\nGRANT ALL ON foobar.* TO \u0026#39;razon\u0026#39;@\u0026#39;localhost\u0026#39; ","date":"2020-01-09","permalink":"https://razonyang.com/zh-tw/posts/mysql/create-user-and-grant-privileges/","series":null,"tags":["MySQL"],"title":"MySQL 創建用戶並授權"},{"categories":["Linux"],"content":"在使用 yum 如果出現以下提示，一般是設置了多個 epel 倉庫：\n Repository epel is listed more than once in the configuration\n 倉庫列表位於 /etc/yum.repos.d/：\n$ ls -l /etc/yum.repos.d/ | grep pel -rw-r--r-- 1 root root 230 Jan 8 11:29 CentOS-Epel.repo -rw-r--r-- 1 root root 1050 Sep 18 07:25 epel.repo -rw-r--r-- 1 root root 1149 Sep 18 07:25 epel-testing.repo 可以看到系統有多個 epel 的倉庫，我們逐一檢查：\n$ cat /etc/yum.repos.d/CentOS-Epel.repo [epel] ... $ cat /etc/yum.repos.d/epel.repo [epel] ... 然後把多餘的 [epel] 註釋或者刪除即可。\n","date":"2020-01-08","permalink":"https://razonyang.com/zh-tw/posts/centos/epel-listed-more-than-once/","series":null,"tags":["CentOS","EPEL"],"title":"CentOS Repository epel is listed more than once in the configuration"},{"categories":["Linux"],"content":"CentOS 安裝免費 Let’s Encrypt SSL 證書教程。\n安裝 CentOS 8\n# curl -O https://dl.eff.org/certbot-auto # mv certbot-auto /usr/local/bin/certbot-auto # chmod 0755 /usr/local/bin/certbot-auto CentOS 7\n# yum install certbot-nginx 生成證書 CentOS 8\n# /usr/local/bin/certbot-auto --nginx -d errlogs.com -d www.errlogs.com CentOS 7\n# certbot --nginx -d errlogs.com -d www.errlogs.com  -d 指定域名  自動更新 證書有效期為三個月，我們需要添加定時任務自動更新證書。\n# crontab -e # CentOS 8 2 0 * * * /usr/local/bin/certbot-auto renew --dry-run # CentOS 7 2 0 * * * /usr/bin/certbot renew --quiet # systemctl reload crond ","date":"2020-01-08","permalink":"https://razonyang.com/zh-tw/posts/centos/nginx-lets-encrypt/","series":null,"tags":["CentOS","Let's Encrypt","Nginx","SSL"],"title":"CentOS 安裝免費 Let’s Encrypt SSL 證書"},{"categories":["Linux"],"content":"CentOS 7 升級 MariaDB 方法。\n$ curl -sS https://downloads.mariadb.com/MariaDB/mariadb_repo_setup | sudo bash $ sudo yum update ","date":"2020-01-08","permalink":"https://razonyang.com/zh-tw/posts/centos/upgrade-mariadb/","series":null,"tags":["CentOS","MariaDB"],"title":"CentOS 7 升級 MariaDB"},{"categories":["Programing"],"content":"最近購買了 Redis 雲數據庫，打算將 PHP Session 存放到 Redis。\n安裝 首先需要安裝 PHPRedis 擴展，這裡以 CentOS 為例：\n# yum install php-redis # pecl install redis  在 CentOS 中可以通過 yum install php-pear 安裝 pecl 命令。\n 其他環境可以參考官方安裝指南\r。\n配置 緊接著進行 Redis 配置，其中主要配置為 session.save_handler 和 session.save_path：\nsession.save_handler = redis session.save_path = \u0026#34;tcp://host:port?auth=password\u0026amp;database=0\u0026#34; session.save_path 中 auth 為 Redis 密碼，database 為數據庫，都是可選的。\n測試 測試前，需要重啟 PHP 服務，然後寫個測試腳本：\nsession_start(); $count = $_SESSION[\u0026#39;count\u0026#39;] ?? 0; $_SESSION[\u0026#39;count\u0026#39;] = ++$count; echo $count; 另外開啟 Redis 監控：\n$ redis-cli -h \u0026lt;host\u0026gt; -a \u0026lt;password\u0026gt; monitor OK 如果沒有差錯，可以看到頁面數值隨刷新次數遞增，監控結果類似：\n1578351808.114912 [0 172.18.124.156:40210] \u0026#34;GET\u0026#34; \u0026#34;PHPREDIS_SESSION:3aac30ca920c61b2cc21677e41b7dad3\u0026#34; 1578351808.116330 [0 172.18.124.156:40210] \u0026#34;SETEX\u0026#34; \u0026#34;PHPREDIS_SESSION:3aac30ca920c61b2cc21677e41b7dad3\u0026#34; \u0026#34;1440\u0026#34; \u0026#34;count|i:1;\u0026#34; 在 Redis 裡面也可以看到相關 Session 的信息：\n$ redis-cli -h \u0026lt;host\u0026gt; \u0026gt; keys * 1) \u0026#34;PHPREDIS_SESSION:3aac30ca920c61b2cc21677e41b7dad3\u0026#34; 自此安裝完成。\n問題排查 如果出現問題，先利用 phpinfo 確保 session.save_handler 和 session.save_path 是否生效。測試後請記得刪除，否則暴露敏感信息，比如 Redis 連接信息 \u0026ndash; PHP 安全 – 不要暴露 phpinfo\r。\n如果 php.ini 已經配置了 session.save_handler 和 session.save_path，但是沒有生效，有三個可能性高的原因：\n 修改後沒有保存和重啟 PHP 服務。 修改了錯誤的 php.ini，phpinfo 會打印其加載的 ini 文件，仔細檢查即可。 PHP-FPM 的 www.conf 中覆蓋了 php.ini 的配置，比如 php_value[session.save_handler] = files  如果配置正常，利用 redis-cli monitor 查看指令是否正常，筆者安裝時就遇到 php 配置問題導致 Redis 無法保存 Session 的問題，詳情可以參看 Issue\r。\n","date":"2020-01-06","permalink":"https://razonyang.com/zh-tw/posts/php/session-handler-redis/","series":null,"tags":["PHP","Redis","Session"],"title":"PHP 設置 Redis 存儲 Session"},{"categories":["Linux"],"content":"YAY 默認的 AUR 鏡像很慢，我們可以通過 --aururl 指定國內的 AUR 鏡像。\n$ yay --aururl \u0026#34;mirror“ --save 比如清華 AUR 鏡像\n$ yay --aururl \u0026#34;https://aur.tuna.tsinghua.edu.cn\u0026#34; --save ","date":"2020-01-06","permalink":"https://razonyang.com/zh-tw/posts/archlinux/yay-aur-mirror/","series":null,"tags":["Arch Linux","AUR","YAY"],"title":"YAY 設置 AUR 鏡像"},{"categories":["Programing"],"content":"有時候為了驗證和測試配置是否正常，可能會利用 phpinfo 打印配置信息，而測試完畢後千萬別忘記刪掉對應的文件，因為 phpinfo 包含了很多敏感的數據。\n舉個例子，如果你配置了 Redis 作為 Session Handler，那麼你的 Redis 連接信息就已經暴露出去了，這是十分危險的行為。\n建議 正因如此，我們應該儘量避免使用 phpinfo，特別是生產環境。我們完全可以利用其它函數進行相應的測試，如：ini_get、extension_loaded 等。\n命令行可以直接用 php -i 查看。\n","date":"2020-01-05","permalink":"https://razonyang.com/zh-tw/posts/php/security-do-not-expose-your-phpinfo/","series":null,"tags":["PHP","phpinfo"],"title":"PHP 安全 – 不要暴露 phpinfo"},{"categories":["Programing"],"content":"此前筆者搜索過不少前後端分離，身份驗證 token 應該存放在哪的問題，不少結果都說放到 Local Storage，但放到 Local Storage 真的安全嗎？這正是分享本篇文章的原因，希望能幫助到其他有相同疑惑的開發者。\nSeriously. Just stop it already.\nI don’t know what it is, exactly, that drives so many developers to store session information in local storage\r, but whatever the reason: the practice needs to die out. Things are getting completely out of hand.\nAlmost every day I stumble across a new website storing sensitive user information in local storage and it bothers me to know that so many developers are opening themselves up to catastrophic security issues by doing so.\nLet’s have a heart-to-heart and talk about local storage and why you should stop using it to store session data.\n Source: Please Stop Using Local Storage\r What is Local Storage? I’m sorry if I was a bit grumpy earlier. You don’t deserve that! Heck, you might not even be familiar with what local storage is, let alone be using it to store your session information!\nLet’s start with the basics: local storage is a new feature of HTML5 that basically allows you (a web developer) to store any information you want in your user’s browser using JavaScript. Simple, right?\nIn practice, local storage is just one big old JavaScript object that you can attach data to (or remove data from). Here’s an example of some JavaScript code that stores some of my personal info in local storage, echoes it back to me, and then (optionally) removes it:\n// You can store data in local storage using either syntax  localStorage.userName = \u0026#34;rdegges\u0026#34;; localStorage.setItem(\u0026#34;favoriteColor\u0026#34;, \u0026#34;black\u0026#34;); // Once data is in localStorage, it\u0026#39;ll stay there forever until it is  // explicitly removed  alert(localStorage.userName + \u0026#34; really likes the color \u0026#34; + localStorage.favoriteColor + \u0026#34;.\u0026#34;); // Removing data from local storage is also pretty easy. Uncomment the lines  // below to destroy the entries  //localStorage.removeItem(\u0026#34;userName\u0026#34;);  //localStorage.removeItem(\u0026#34;favoriteColor\u0026#34;); If you run the JavaScript code above in your browser on a test HTML page, you’ll see the phrase “rdegges really likes the color black.” in an alert message. If you then open up your developer tools, you’ll be able to see the that both the userName and favoriteColor variables are both stored in local storage in your browser:\nNow you might be wondering if there’s some way to use local storage so that the data you store is automatically deleted at some point and you don’t need to manually delete every single variable you put in there. Luckily, the HTML5 working group (shout out!) has your back. They added something called sessionStorage to HTML5 which works exactly the same as local storage except that all data it stores is automatically deleted when the user closes their browser tab.\nWhat’s Cool About Local Storage? Now that we’re on the same page about what local storage is, let’s talk about what makes it cool! Even though the whole point of this article is to dissuade you from using local storage to store session data, local storage still has some interesting properties.\nFor one thing: it’s pure JavaScript! One of the annoying things about cookies (the only real alternative to local storage) is that they need to be created by a web server. Boo! Web servers are boring and complex and hard to work with.\nIf you’re building a static site (like a single page app, for instance), using something like local storage means your web pages can run independently of any web server. They don’t need any backend language or logic to store data in the browser: they can just do it as they please.\nThis is a pretty powerful concept and one of the main reasons that local storage is such a hit with developers.\nAnother neat thing about local storage is that it doesn’t have as many size constraints as cookies. Local storage provides at least 5MB of data storage across all major web browsers, which is a heck of a lot more than the 4KB (maximum size) that you can store in a cookie.\nThis makes local storage particularly useful if you want to cache some application data in the browser for later usage. Since 4KB (the cookie max size) isn’t a lot, local storage is one of your only real alternative options.\nWhat Sucks About Local Storage OK. We talked about the good, now let’s spend a minute (or two!) talking about the bad.\nLocal storage is soooo basic. WHEW. I feel better already getting that off my chest. Local storage is just an incredibly basic, simple API.\nI feel like most developers don’t realize just how basic local storage actually is:\n  It can only store string data. Boo. This makes it pretty useless for storing data that’s even slightly more complex than a simple string. And sure, you could serialize everything including data types into local storage, but that’s an ugly hack.\n  It is synchronous. This means each local storage operation you run will be one-at-a-time. For complex applications this is a big no-no as it’ll slow down your app’s runtime.\n  It can’t be used by web workers\r=/ This means that if you want to build an application that takes advantage of background processing for performance, chrome extensions, things like that: you can’t use local storage at all since it isn’t available to the web workers.\n  It still limits the size of data you can store (~5MB across all major browsers). This is a fairly low limit for people building apps that are data intensive or need to function offline.\n  Any JavaScript code on your page can access local storage: it has no data protection whatsoever. This is the big one for security reasons (as well as my number one pet peeve in recent years).\n  To keep it short, here’s the only situation in which you should use local storage: when you need to store some publicly available information that is not at all sensitive, doesn’t need to be used in a high performance app, isn’t larger than 5MB, and consists of purely string data.\nIf the app you’re using doesn’t fit the above description: don’t use local storage. Use something else (more on this later).\nWhy Local Storage is Insecure and You Shouldn’t Use it to Store Sensitive Data Here’s the deal: most of the bad things about local storage aren’t all that important. You can still get away with using it but you’ll just have a slightly slower app and minor developer annoyance. But security is different. The security model of local storage IS really important to know and understand, since it will dramatically affect your website in ways you may not realize.\nAnd the thing about local storage is that it is not secure! Not at all! Everyone who uses local storage to store sensitive information such as session data, user details, credit card info (even temporarily!) and anything else you wouldn’t want publicly posted to Facebook is doing it wrong.\nLocal storage wasn’t designed to be used as a secure storage mechanism in a browser. It was designed to be a simple string only key/value store that developers could use to build slightly more complex single page apps. That’s it.\nWhat’s the most dangerous thing in the entire world? That’s right! JavaScript.\nThink about it like this: when you store sensitive information in local storage, you’re essentially using the most dangerous thing in the world to store your most sensitive information in the worst vault ever created: not the best idea.\nWhat the problem really boils down to is cross-site scripting attacks (XSS\r). I won’t bore you with a full explanation of XSS, but here’s the high level:\nIf an attacker can run JavaScript on your website, they can retrieve all the data you’ve stored in local storage and send it off to their own domain. This means anything sensitive you’ve got in local storage (like a user’s session data) can be compromised.\nNow, you might be thinking “So what? My website is secure. No attacker can run JavaScript on my website.”\nAnd that’s a reasonable point. If your website is truly secure and no attacker can run JavaScript code on your website then you are technically safe, but in reality that is incredibly hard to achieve. Let me explain.\nIf your website contains any third party JavaScript code included from a source outside your domain:\n Links to bootstrap Links to jQuery Links to Vue, React, Angular, etc. Links to any ad network code Links to Google Analytics Links to any tracking code  Then you are currently at risk for having an attacker run JavaScript on your website. Let’s say your website has the following script tag embedded inside it:\n\u0026lt;script src=\u0026#34;https://awesomejslibrary.com/minified.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; In this case, if awesomejslibrary.com is compromised and their minified.js script gets altered to:\n Loop through all data in local storage Send it to an API built to collect stolen information  … then you are completely screwed. In this situation the attacker would have easily been able to compromise anything you had stored in local storage and you would never notice. Not ideal.\nAs engineers, I think we’re frequently susceptible to thinking that we would never embed third party JavaScript in our websites. But in the real world, this scenario rarely plays out.\nAt most companies the marketing team directly manages the public website using different WYSIWYG editors and tooling. Can you really be sure that nowhere on your site are you using third party JavaScript? I’d argue “no”.\nSo to err on the side of caution and dramatically reduce your risk for a security incident: don’t store anything sensitive in local storage.\nPSA: Don’t Store JSON Web Tokens in Local Storage While I feel like I made myself clear that you should never ever store sensitive information in local storage in the previous section, I feel the need to specifically call out JSON Web Tokens (JWTs).\nThe biggest security offenders I see today are those of us who store JWTs (session data) in local storage. Many people don’t realize that JWTs are essentially the same thing as a username/password.\nIf an attacker can get a copy of your JWT\r, they can make requests to the website on your behalf and you will never know. Treat your JWTs like you would a credit card number or password: don’t ever store them in local storage.\nThere are thousands of tutorials, YouTube videos, and even programming classes at universities and coding bootcamps incorrectly teaching new developers to store JWTs in local storage as an authentication mechanism. THIS INFORMATION IS WRONG. If you see someone telling you to do this, run away!\nWhat to Use Instead of Local Storage So with all of local storage’s shortcomings, what should you use instead? Let’s explore the alternatives!\nSensitive Data If you need to store sensitive data, you should always use a server-side session. Sensitive data includes:\n User IDs Session IDs JWTs Personal information Credit card information API keys And anything else you wouldn’t want to publicly share on Facebook  If you need to store sensitive data, here’s how to do it:\n  When a user logs into your website, create a session identifier for them and store it in a cryptographically signed cookie. If you’re using a web framework, look up “how to create a user session using cookies” and follow that guide.\n  Make sure that whatever cookie library your web framework uses is setting the httpOnly cookie flag. This flag makes it impossible for a browser to read any cookies, which is required in order to safely use server-side sessions with cookies. Read Jeff Atwood’s article\rfor more information. He’s the man.\n  Make sure that your cookie library also sets the SameSite=strict cookie flag (to prevent CSRF\rattacks), as well as the secure=true flag (to ensure cookies can only be set over an encrypted connection).\n  Each time a user makes a request to your site, use their session ID (extracted from the cookie they send to you) to retrieve their account details from either a database or a cache (depending on how large your website is)\n  Once you have the user’s account info pulled up and verified, feel free to pull any associated sensitive data along with it\n  This pattern is simple, straightforward, and most importantly: secure. And yes, you can most definitely scale up a large website using this pattern. Don’t tell me that JWTs are “stateless” and “fast” and you have to use local storage to store them: you’re wrong!\nNon-String Data If you need to store data in the browser that isn’t sensitive and isn’t purely string data, the best option for you is IndexedDB. It’s an API that lets you work with a database-esque object store in the browser.\nWhat’s great about IndexedDB is that you can use it to store typed information: integers, floats, etc. You can also define primary keys, handle indexing, and create transactions to prevent data integrity issues.\nA great tutorial for learning about (and using) IndexedDB is this Google tutorial\r.\nOffline Data If you need your app to run offline, your best option is to use a combination of IndexedDB (above) along with the Cache API (which is a part of Service Workers).\nThe Cache API allows you to cache network resources that your app needs to load.\nA great tutorial for learning about (and using) the Cache API is this Google tutorial\r.\nPlease Stop Using Local Storage Now that we’ve had a chance to talk about local storage, I hope you understand why you (probably) shouldn’t be using it.\nUnless you need to store publicly available information that:\n Is not at all sensitive Doesn’t need to be used in an ultra high performance app Isn’t larger than 5MB Consists of purely string data  … don’t use local storage! Use the right tool for the job.\nAnd please, please, whatever you do, do not store session information (like JSON Web Tokens) in local storage. This is a very bad idea and will open you up to an extremely wide array of attacks that could absolutely cripple your users.\nHave a question? Shoot me an email\r.\nStay safe out there =)\nNOTE: For those of you who made it this far who are wondering why I didn’t specifically call out Content Security Policy\ras a way to mitigate the effects of XSS, I specifically chose not to include this because it cannot help in the situation I described above. Even if you use CSP to whitelist all third party JavaScript domains, that does nothing to prevent XSS if the third party provider is compromised.\nAnd while we’re at it: subresource integrity\r(while cool) is also not a global solution to this issue. For most marketing tools, ad networks, etc. (which are by far the most commonly used types of third party JavaScript), subresource integrity is almost never used as the providers of those scripts want to change them frequently so they can silently update functionality for their users.\nUPDATE: I’m not the only one who thinks you should never store anything sensitive in local storage. So does OWASP\r:\n … In other words, any authentication your application requires can be bypassed by a user with local privileges to the machine on which the data is stored. Therefore, it’s recommended not to store any sensitive information in local storage.\n","date":"2020-01-04","permalink":"https://razonyang.com/zh-tw/posts/javascript/please-stop-using-local-storage/","series":null,"tags":["JavaScript","Local Storage"],"title":"Please Stop Using Local Storage For Storing Sensitive Data"},{"categories":["Programing"],"content":"在格式化 Go 代碼的時候，經常會用到 gofmt 和 goimports 兩個工具，不過他們之間到底有何區別呢？\n In addition to fixing imports, goimports also formats your code in the same style as gofmt so it can be used as a replacement for your editor\u0026rsquo;s gofmt-on-save hook.\n 根據 goimports 文檔的一段說明，goimports 除了修正 import 代碼塊外，和 gofmt 沒其他區別。至於 import 代碼塊修正，舉個栗子來說明下。\n例子 package main import \u0026#34;stringsx\u0026#34; import \u0026#34;fmt\u0026#34; import \u0026#34;os\u0026#34; func Title(s string) { fmt.Println(strings.Title(s)) } func main() { Title(\u0026#34;hello world\u0026#34;) } 這裡我特意將每個 import 順序亂序，並相隔一行，其中 stringsx 是錯誤的包名，os 是沒有使用到的包。\n我們的期望應該是可以將 import 的包進行排序，去掉未使用的包，並且可以修正錯誤的包名。\ngofmt 首先看下 gofmt 的格式化結果：\npackage main import \u0026#34;stringsx\u0026#34; import \u0026#34;fmt\u0026#34; import \u0026#34;os\u0026#34; func Title(s string) { fmt.Println(strings.Title(s)) } func main() { Title(\u0026#34;hello world\u0026#34;) } goimports  安裝：go get golang.org/x/tools/cmd/goimports\n 接著對比 goimports 結果：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; ) func Title(s string) { fmt.Println(strings.Title(s)) } func main() { Title(\u0026#34;hello world\u0026#34;) } 結論 相對 gofmt，goimports 可以對 import 的包進行排序，去除未使用的包，並修正錯誤的包名。簡而言之，goimports 比 gofmt 更好用，對於強迫症必不可缺。\n題外話 goimports 排序後，內置包和非內置包會有一空行相隔：\nimport ( \u0026#34;errors\u0026#34; ... \u0026#34;github.com/foo/bar\u0026#34; ... ) ","date":"2020-01-04","permalink":"https://razonyang.com/zh-tw/posts/go/gofmt-vs-goimports/","series":null,"tags":["Go","gofmt","goimports"],"title":"Go 語言代碼格式化工具 gofmt vs goimports"},{"categories":["Programing"],"content":"像 Git，Go，Docker 等等的命令行腳本都有很多子命令，那麼我們用 Go 語言如何實現多個子命令的腳本應用呢？\n例子和源碼 先來看一個不含子命令的 CLI 應用：\npackage main import \u0026#34;flag\u0026#34; import \u0026#34;net/http\u0026#34; var handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { w.Write([]byte(\u0026#34;hello world\u0026#34;)) }) func main() { // 綁定監聽地址參數  addr := flag.String(\u0026#34;addr\u0026#34;, \u0026#34;:8080\u0026#34;, \u0026#34;addr\u0026#34;) // 解析參數  flag.Parse() http.ListenAndServe(*addr, handler) } $ go run main.go --addr :23333 $ curl http://localhost:23333 hello world 現在我們來查看下 flag 包的源碼，可以找到以下代碼片段：\nvar CommandLine = NewFlagSet(os.Args[0], ExitOnError) func Parse() { CommandLine.Parse(os.Args[1:]) } 可以清晰地看到 flag 包中的 CommandLine 是一個頂層的 Flag Set，參數解析是從第二個參數開始。\n分析 先從命令格式開始，多個子命令的格式一般為:\nscript \u0026lt;command\u0026gt; [arguments]\r  第二個參數是子命令名稱 第三個參數開始都是該子命令的參數，可選  在先前的例子，我們其實只需要為每個子命令創建一個新的 Flag Set，然後綁定參數並從第三個參數開始解析即可。\n實現 將先前例子的 web 服務改成 serve 子命令，再新增一個 migrate 子命令用於數據遷移：\npackage main import \u0026#34;flag\u0026#34; import \u0026#34;fmt\u0026#34; import \u0026#34;net/http\u0026#34; import \u0026#34;os\u0026#34; var handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { w.Write([]byte(\u0026#34;hello world\u0026#34;)) }) func main() { // serve command  serveCmd := flag.NewFlagSet(\u0026#34;serve\u0026#34;, flag.ExitOnError) serveAddr := serveCmd.String(\u0026#34;addr\u0026#34;, \u0026#34;:8080\u0026#34;, \u0026#34;addr\u0026#34;) // migrate command  migrateCmd := flag.NewFlagSet(\u0026#34;migrate\u0026#34;, flag.ExitOnError) migrateConfig := migrateCmd.String(\u0026#34;config\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;config\u0026#34;) // 第二個參數為子命令名稱  var cmd string if len(os.Args) \u0026gt; 1 { cmd = os.Args[1] } switch cmd { case \u0026#34;serve\u0026#34;: // 從第三個參數開始解析  serveCmd.Parse(os.Args[2:]) http.ListenAndServe(*serveAddr, handler) case \u0026#34;migrate\u0026#34;: migrateCmd.Parse(os.Args[2:]) fmt.Println(\u0026#34;migrate config:\u0026#34; + *migrateConfig) default: fmt.Println(\u0026#34;Usage: \\n\\tscript \u0026lt;command\u0026gt; [arguments]\u0026#34;) os.Exit(1) } } $ go run main.go Usage: script \u0026lt;command\u0026gt; [arguments] exit status 1 $ go run main.go serve --addr :23333 $ curl http://localhost:23333 hello world $ go run main.go migrate --config config.yaml migrate config:config.yaml ","date":"2020-01-01","permalink":"https://razonyang.com/zh-tw/posts/go/cli-subcommands/","series":null,"tags":["CLI","flag","Go"],"title":"Go 語言實現多個子命令的腳本應用"},{"categories":["Programing"],"content":"Go 語言將 unit 類型轉成 string 的幾種方法和比較。\nfmt.Sprint func sprint(u uint) string { return fmt.Sprint(u) } strconv.FormatUint func formatUint(u uint) string { return strconv.FormatUint(uint64(u), 10) } 性能 func BenchmarkSprint(b *testing.B) { for n := 0; n \u0026lt; b.N; n++ { sprint(uint(n)) } } func BenchmarkFormatUint(b *testing.B) { for n := 0; n \u0026lt; b.N; n++ { formatUint(uint(n)) } } $ go test -bench=. BenchmarkSprint-12 13384656 81.6 ns/op BenchmarkFormatUint-12 44932880 29.5 ns/op 後者明顯性能更好。\n","date":"2019-12-31","permalink":"https://razonyang.com/zh-tw/posts/go/convert-unit-to-string/","series":null,"tags":["Go","uint","string"],"title":"Go 語言將 unit 類型轉成 string"},{"categories":["Programing"],"content":"一些在線的 SEO 工具檢測結果表示主頁 H1 標籤過多，經過查看了主題的源碼，主頁的文章列表嵌套了文章頁的模板（content.php），因此只需要對 content.php 稍作修改即可。\n 對於一個頁面多個 H1 標籤是否有礙 SEO 沒有定論，筆者也不瞭解這塊，本文純屬從技術角度來修改主題，避免頁面出現多個 H1 標籤。\n 解決 先看下 content.php 的代碼片段：\n\u0026lt;h1 class=\u0026#34;entry-title\u0026#34;\u0026gt;\u0026lt;?php the_title(); ?\u0026gt;\u0026lt;/h1\u0026gt; 首頁和文章詳情頁都共用這一內容模板，我們只需要稍作判斷即可，比如首頁時，將 H1 改為 H2：\n\u0026lt;?php if (is_front_page()): ?\u0026gt;\u0026lt;h2 class=\u0026#34;entry-title\u0026#34;\u0026gt;\u0026lt;?php the_title(); ?\u0026gt;\u0026lt;/h2\u0026gt; \u0026lt;?php else: ?\u0026gt; \u0026lt;h1 class=\u0026#34;entry-title\u0026#34;\u0026gt;\u0026lt;?php the_title(); ?\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;?php endif; ?\u0026gt; 如果頁面存在更加複雜的判斷，也可以改成：\n$titleTag = is_front_page() ? \u0026#39;h2\u0026#39;: \u0026#39;h1\u0026#39;; \u0026lt;\u0026lt;?= $titleTag ?\u0026gt;class=\u0026#34;entry-title\u0026#34;\u0026gt;\u0026lt;?php the_title(); ?\u0026gt;\u0026lt;/\u0026lt;?= $titleTag ?\u0026gt;\u0026gt; ","date":"2019-12-30","permalink":"https://razonyang.com/zh-tw/posts/wordpress/avoid-using-too-many-h1-tag/","series":null,"tags":["WordPress"],"title":"WordPress 避免頁面出現過多 H1 標籤"},{"categories":["Linux"],"content":"最近發現 KDE Plasma 的主題（Global Theme）界面沒有刪除按鈕，Google 了良久，也沒有找到對應的目錄，可能 KDE 在不同 Linux 發行版中的配置不一樣吧。\n按道理說，我們只需要刪除對應的主題目錄，關鍵就在於如何找到主題的目錄了。既然我們知道了要刪除的主題的名字，用 find 命令查找即可，另外在安裝主題的時候，並不需要任何權限，主題的安裝位置很可能就在用戶的主目錄，所以命令如下：\n$ find ~/ -name theme /home/razon/.local/share/plasma/look-and-feel/theme  ～/ 指定搜索的目錄為用戶的主目錄 theme 是要刪除的主題名  找到相應主題後，刪除即可：\n$ rm -r /home/razon/.local/share/plasma/look-and-feel/theme 重新打開主題設置，應該就可以看到相應主題已經被刪除了。\n","date":"2019-12-30","permalink":"https://razonyang.com/zh-tw/posts/kde/plasma-uninstall-global-theme/","series":null,"tags":["KDE","PLASMA"],"title":"KDE Plasma 刪除主題（Global Theme）"},{"categories":["Linux"],"content":"Linux 下 tar 的使用說明。\n解壓 $ tar -xvf archive.tar  x 表示解壓。 f 表示要解壓的文件。 v 可以忽略，其表示 Verbose 模式。  解壓到指定目錄 可以通過 -C 參數指定解壓到的目錄：\n$ tar -xvf archive.tar -C /path/to/dir 壓縮 將 foo 和 bar 壓縮到 archive.tar：\n$ tar -cf archive.tar foo bar  c 表示創建壓縮文件。 f 表示要壓縮到的文件。  壓縮目錄 $ tar -zvcf archive.tar /path/to/dir  z 使用 gzip 進行壓縮。  幫助 $ tar --help ","date":"2019-12-22","permalink":"https://razonyang.com/zh-tw/posts/linux/tar/","series":null,"tags":["tar"],"title":"tar 基本用法"},{"categories":["Linux"],"content":"Arch Linux 的鏡像配置文件在 /etc/pacman.d/mirrorlist，裡面一般涵蓋了國內的鏡像源。\n# vim /etc/pacman.d/mirrorlist 搜索 China，將其中一個 Server 放在頭部即可。\n","date":"2019-12-22","permalink":"https://razonyang.com/zh-tw/posts/archlinux/mirror-list/","series":null,"tags":["Arch Linux"],"title":"Arch Linux 修改國內源"},{"categories":["Linux"],"content":"PHP 項目開發難免會需要使用到多個 PHP 版本，本文將介紹如何在 Arch Linux 上安裝多個 PHP 版本。\n首先我們需要先安裝一個 AUR 助手\r，本文以 YAY\r為例。\n檢索 假設我們要安裝 PHP 7.2：\n$ yay -Ss php72 則會列出所有關於 PHP 7.2 相關的軟件包，按需安裝即可。\n安裝 $ yay -S php72 php72-fpm php72-intl php72-gd $ php72 -v PHP 7.2.25 (cli) (built: Dec 22 2019 04:31:17) ( NTS ) Copyright (c) 1997-2018 The PHP Group Zend Engine v3.2.0, Copyright (c) 1998-2018 Zend Technologies 配置 配置位於 /etc/php72/，按需修改即可。\n其他版本 其他版本也一樣，將 php72 改成相應的版本即可，如：php56、php70、php71。\n題外話 對於新項目，筆者都是用最新版本的，現在官方支持的 PHP 版本\r最低為 7.2，使用舊版本，出問題需要升級 PHP 時，就可能出現比較多麻煩事，所以最新版應該是新項目的最佳選擇。\n","date":"2019-12-22","permalink":"https://razonyang.com/zh-tw/posts/archlinux/multiple-php-versions/","series":null,"tags":["Arch Linux","PHP"],"title":"Arch Linux 如何安裝多個 PHP 版本"},{"categories":["Linux"],"content":"Linux 下 unzip 的使用說明。\n安裝 Ubuntu # apt install unzip CentOS # yum install unzip Arch Linux # pacman -S unzip 用法 $ unzip file.zip 解壓到指定目錄 使用 -d 指定要解壓到的目錄：\n$ unzip file.zip -d /path/to/dir 幫助 $ unzip -h ","date":"2019-12-22","permalink":"https://razonyang.com/zh-tw/posts/linux/unzip/","series":null,"tags":["UnZip"],"title":"unzip 基本用法"},{"categories":["Linux"],"content":"Arch Linux Network Manager 的安裝和使用教程。\n安裝 # pacman -S networkmanager 啟動 # systemctl enable NetworkManager # systemctl start NetworkManager  注意服務名的大小寫。\n 命令行 WIFI 查看 WIFI 列表：\n$ nmcli device wifi list 連接 WIFI：\n$ nmcli device wifi connect wifiname password wifipassword wifiname 和 wifipassword 分別為 WIFI 名稱和密碼，如果有空格，可以用反斜槓（轉義符）+空格 \\ 表示空格。\n圖形 https://wiki.archlinux.org/index.php/NetworkManager#Front-ends\r","date":"2019-12-21","permalink":"https://razonyang.com/zh-tw/posts/archlinux/network-manager/","series":null,"tags":["Arch Linux","Network Manager"],"title":"Arch Linux Network Manager 的安裝和使用"},{"categories":["Linux"],"content":"本文介紹的是 UEFI 系統的 GRUB 安裝教程。\n安裝 # pacman -S grub efibootmgr  如果是雙系統，你還需要安裝 os-prober\n # grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=GRUB --removable  /boot 是我的啟動分區。\n 配置 配置文件為：/etc/default/grub。\n生成配置（每次修改都需要重新生成配置）\n# grub-mkconfig -o /boot/grub/grub.cfg    參數 推薦值 說明     GRUB_DEFAULT saved    GRUB_SAVEDEFAULT true 是否記住上次的選擇，需要將 GRUB_DEFAULT 設置為 saved   GRUB_TIMEOUT 5 引導選擇界面逗留時間，單位秒   GRUB_CMDLINE_LINUX_DEFAULT  Linux 默認啟動參數   GRUB_CMDLINE_LINUX  Linux 啟動參數，如果是 4k 屏，建議加上 video=1024x768   ","date":"2019-12-21","permalink":"https://razonyang.com/zh-tw/posts/archlinux/grub/","series":null,"tags":["Arch Linux","GRUB"],"title":"Arch Linux 安裝 GRUB"},{"categories":["Linux"],"content":"記一次 ArchLinux 安裝步驟。\nU 盤啟動 首先下載 Arch Linux\r的 ISO 鏡像，然後使用刻錄工具（如 Windows 下的 USBWriter， Linux 下的 dd 命令）刻錄到 U 盤即可。\n macOS 應該也有 dd 命令。\n  利用 dd 命令刻錄U盤啟動盤\r  啟動 LiveUSB 由於筆者的筆記本是 4K 屏，如果不設置 GRUB 的引導參數，進入系統後字體會十分的小，不利於安裝。只需要按 e 編輯引導記錄，後面加上 video=1024x768 或者 nomodeset 即可。\n磁盤分區 筆者預留了 120GiB 左右的磁盤容量給 Linux，用於辦公足矣。以下是我的分區方案：\n   分區 類型 大小 說明     root ext4 50GiB 如果日常使用 Docker 的話，建議 100 GiB   swap swap 16GiB 一般和內存大小相同   home ext4 剩餘的容量 -    分區方案很多，不過建議單獨一個 home 分區，因為我們幾乎所有的用戶資料都會放在這裡，即使重裝系統或者其他 Linux 發行版，我們都不用擔心這個 home 分區。\n可以使用 fdisk 或者 parted 進行分區，這裡不再贅述，下面是我的分區：\n# fdisk -l ... Device Start End Sectors Size Type /dev/nvme0n1p1 2048 534527 532480 260M EFI System /dev/nvme0n1p2 534528 567295 32768 16M Microsoft reserved /dev/nvme0n1p3 567296 419997695 419430400 200G Microsoft basic data /dev/nvme0n1p4 419997696 629712895 209715200 100G Microsoft basic data /dev/nvme0n1p5 629712896 734570495 104857600 50G Microsoft basic data /dev/nvme0n1p6 998166528 1000214527 2048000 1000M Windows recovery environment /dev/nvme0n1p7 734570496 839428095 104857600 50G Linux filesystem /dev/nvme0n1p8 839428096 872982527 33554432 16G Linux filesystem /dev/nvme0n1p9 872982528 998166527 125184000 59.7G Linux filesystem 可以看到 /dev/nvme0n1p7 - 9 是剛創建的 Linux 分區，分別為 /、swap 和 /home 分區，其中由於我的是雙系統，其中標記有 EFI 的分區，也就是 /dev/nvme0n1p1 是 boot 分區。\n分區類型 # mkfs.ext4 /dev/nvme0n1p7 # mkfs.ext4 /dev/nvme0n1p9 # mkswap /dev/nvme0n1p8 # swapon /dev/nvme0n1p8 掛載分區 # mount /dev/nvme0n1p7 /mnt # mkdir /mnt/home # mount /dev/nvme0n1p9 /mnt/home # mkdir /mnt/boot # mount /dev/nvme0n1p1 /mnt/boot 網絡 在進行下一步前，我們需要確保網絡是否正常，我們需要網絡去下載和安裝軟件包。\n有線 有線連接一般會自動處理和連接，如果身邊沒有其他網絡設備，也可以用手機 USB 共享網絡給電腦，不過需要的流量很大，不推薦使用。\nWIFI # wifi-menu -o  該命令會掃描附近的 WIFI，填寫密碼後連接。\n 測試 $ ping archlinux.org 國內鏡像源 在安裝必須軟件之前，先修改下國內源，否則嚴重影響你的安裝進度。\n# vim /etc/pacman.d/mirrorlist 搜索 China，選擇其中一個 Server 粘貼到文件第一行即可。如果你使用 vi/vim，可以 yy 複製一行，p 粘貼所複製的一行。\n安裝必須的軟件 # pacstrap /mnt base base-devel linux linux-firmware  base-devel 不是必須的，建議加上\n 配置系統 Fstab # genfstab -U /mnt \u0026gt;\u0026gt; /mnt/etc/fstab Chroot # arch-chroot /mnt 時區 # ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 本地化 # nano /etc/locale.gen en_US.UTF-8 UTF-8 zh_CN.UTF-8 UTF-8 zh_TW.UTF-8 UTF-8 # locale-gen # nano /etc/locale.conf LANG=en_US.UTF-8 密碼 # passwd 字體 筆者比較喜歡文泉驛的字體：\n# pacman -S wqy-microhei wqy-zenhei wqy-bitmapfont 你也可以安裝其他中文字體\r。\n後續 自此係統安裝幾乎完成，但是先別急著重啟，還差系統引導、網絡兩個重要步驟，否則你還得 live 環境重新 chroot，比較繁瑣。\n GRUB\r Network Manager\r Fcitx 輸入法\r ","date":"2019-12-21","permalink":"https://razonyang.com/zh-tw/posts/archlinux/installation/","series":null,"tags":["Arch Linux"],"title":"Arch Linux 安裝教程"},{"categories":["Linux"],"content":"Arch Linux 安裝 TIM 教程。\n TIM 需要開啟 Arch Linux multilib\r。\n 安裝 $ yay -S deepin.com.qq.office 此處以 yay 為例，你也可以用其他已有的 AUR 助手，或者手動下載解壓，再 makepkg -si。\n問題 如果桌面快捷方式啟動不了，可以通過命令行啟動，來查看具體的錯誤：\n$ /opt/deepinwine/apps/Deepin-TIM/run.sh 相關  KDE Plasma 無法啟動 TIM\r ","date":"2019-12-21","permalink":"https://razonyang.com/zh-tw/posts/archlinux/tim/","series":null,"tags":["Arch Linux","TIM"],"title":"Arch Linux 安裝 TIM"},{"categories":["Linux"],"content":"Arch Linux 安裝 MariaDB。\n# pacman -S mariadb # mariadb-install-db --user=mysql --basedir=/usr --datadir=/var/lib/mysql # systemctl start mysqld # mysql_secure_installation # systemctl enable mysqld ","date":"2019-12-21","permalink":"https://razonyang.com/zh-tw/posts/archlinux/mariadb/","series":null,"tags":["Arch Linux","MariaDB"],"title":"Arch Linux 安裝 MariaDB"},{"categories":["Linux"],"content":"Arch Linux 有些軟件是 32 位的，我們需要開啟 multilib 才可以安裝。下面介紹如何 Arch Linux 如何開啟 multilib。\n啟用 取消註釋 /etc/pacman.conf 文件中的下面兩行即可：\n[multilib]\rInclude = /etc/pacman.d/mirrorlist\r更新 啟用後，我們還需要更新軟件包列表並升級系統：\n# pacman -Syu ","date":"2019-12-21","permalink":"https://razonyang.com/zh-tw/posts/archlinux/enable-multilib/","series":null,"tags":["Arch Linux","multilib"],"title":"Arch Linux 開啟 multilib"},{"categories":["Linux"],"content":"Arch Linux 已經成為筆者主要的辦公系統，本文將介紹一些比較常用的軟件。\nSheel  Zsh\r  終端  Terminator  文本  Vim  網絡  Chromium FireFox  辦公  TIM\r WPS Office\r  娛樂  網易雲音樂\r  圖片處理  GIMP  開發  Nginx\r Redis\r MySQL(MariaDB)\r Visual Studio Code\r PHP\r DBeaver\r圖形數據庫管理軟件，幾乎支持所有數據庫 Filezilla FTP 客戶端 Dia 流程圖、UML 等 Putty SSH 客戶端 ","date":"2019-12-21","permalink":"https://razonyang.com/zh-tw/posts/archlinux/recommended-softwares/","series":null,"tags":["Arch Linux","Software"],"title":"Arch Linux 常用軟件推薦"},{"categories":["Linux"],"content":"Arch Linux 安裝 PHP 教程。\n安裝 # pacman -S php \\ php-fpm \\  composer \\  php-gd \\  php-intl 可以通過 sudo pacman -Ss php- 列出相關擴展。\nFPM 配置 # vim /etc/php/php-fpm.d/www.conf 開機自啟 # systemctl enable php-fpm ","date":"2019-12-21","permalink":"https://razonyang.com/zh-tw/posts/archlinux/php/","series":null,"tags":["Arch Linux","PHP"],"title":"Arch Linux 安裝 PHP"},{"categories":["Linux"],"content":"YAY（Yet another Yogurt） 是 Arch Linux 的一個 AUR（Arch User Repository） 助手，可以讓我們更方便地安裝 AUR 上的軟件包，如：QQ、TIM、WPS OFFICE 等等。下面介紹 YAY 的安裝和使用。\n安裝 $ git clone https://aur.archlinux.org/yay $ cd yay $ makepkg -si 如果沒法 git clone，可以到 YAY\r軟件包頁面下載快照並解壓。\n","date":"2019-12-21","permalink":"https://razonyang.com/zh-tw/posts/archlinux/yay/","series":null,"tags":["Arch Linux","AUR","YAY"],"title":"Arch Linux 安裝 YAY"},{"categories":["Linux"],"content":"Arch Linux SDDM 黑屏的解決方法。\n安裝 xrandr：\n$ sudo pacman -S xrandr 編輯 /usr/share/sddm/scripts/Xsetup 並添加以下命令即可：\nxrandr --auto  如果設置了 sddm 開機自啟，你可能需要 chroot 到原系統進行修改。\n","date":"2019-12-21","permalink":"https://razonyang.com/zh-tw/posts/archlinux/sddm-black-screen/","series":null,"tags":["Arch Linux","SDDM"],"title":"Arch Linux SDDM 黑屏的解決方法"},{"categories":["Linux"],"content":"Arch Linux 安裝中文輸入法 Fcitx。\n安裝 $ sudo pacman -S fcitx fcitx-googlepinyin fcitx-im fcitx-configtool fcitx-googlepinyin 是我偏愛的輸入法之一，你可以在中文輸入法\r中找到其他輸入法，比如搜狗輸入法。\nfcitx-configtool 是圖形配置軟件，後面會用到。\n環境變量 編輯 ~/.pam_environment，輸入以下內容：\nGTK_IM_MODULE=fcitx\rQT_IM_MODULE=fcitx\rXMODIFIERS=@im=fcitx\r 需要重新登錄後生效。\n配置輸入法 安裝完畢了，啟動 fcitx，然後右鍵托盤圖標，配置添加我們的輸入法即可，如：Google Pinyin。\n排查錯誤 如果輸入法沒法正常工作，可以通過 fcitx-diagnose 排查。\n","date":"2019-12-21","permalink":"https://razonyang.com/zh-tw/posts/archlinux/fcitx/","series":null,"tags":["Arch Linux","Fcitx"],"title":"Arch Linux 安裝中文輸入法 Fcitx"},{"categories":["Programing"],"content":"Go 開發不像 PHP（解釋型語言） 那樣可以修改代碼實時生效，而需要重新編譯，如果每次手動執行肯定會降低開發速度。本文將介紹一款開發工具 Modd\r來解決這一問題，它可以監控文件修改並重啟服務進程。\n項目結構 cmd/\rapp/\rmain.go\rconfigs/\rapp.toml\rinternal/\rmodd.conf\r...\r 啟動服務： go run cmd/app/main.go -c configs/app.toml\n 安裝 Modd $ env GO111MODULE=on go get github.com/cortesi/modd/cmd/modd 配置 Modd 在項目根目錄創建 modd.conf，並添加以下內容：\n modd.conf 可以放在任何地方，只需要執行 modd 時通過 -f 參數指定即可。\n **/*.go {\rprep: go test @dirmods\r}\r# Exclude all test files of the form *_test.go\r**/*.go !**/*_test.go {\rdaemon +sigterm: go run cmd/app/main.go -c configs/app.toml\r}\r  prep: go test @dirmods 在執行 modd 時會進行單元測試。 daemon +sigterm: ... 在監控單 go 文件修改時，會終止之前的服務進程，再重新啟動服務進程，後面的啟動參數請按需修改。  執行 Modd $ cd /path/to/project $ $GOPATH/bin/modd [-f /path/to/modd.conf]  $GOPATH 改成你本地的 Go 路徑，也可以將 $GOPATH/bin 添加到環境變量，然後 modd。 -f ... 是可選的，它默認讀取當前工作目錄下的 modd.conf  更多 更多的用法可以在 Modd 倉庫\r瞭解，另外該工具也可以用於很多場景，本文只是介紹其在 Go 開發的一個例子。\n","date":"2019-12-19","permalink":"https://razonyang.com/zh-tw/posts/go/modd/","series":null,"tags":["Go","modd"],"title":"利用 Modd 提高 Go 開發效率"},{"categories":["Programing"],"content":"Visual Studio Code 將其他後綴的文件當成 HTML 文件教程。\nFile -\u0026gt; Preferences -\u0026gt; Settings -\u0026gt; Text Editor -\u0026gt; Files\nsettings.json 添加以下配置即可：\n\u0026#34;files.associations\u0026#34;: { \u0026#34;*.extension\u0026#34;: \u0026#34;html\u0026#34; }  extension 是你要添加的後綴，比如：tmpl, tpl \u0026hellip;\n 同理，也可以將其他後綴的識別為你想要的格式。\n","date":"2019-12-18","permalink":"https://razonyang.com/zh-tw/posts/visual-studio-code/treat-other-extension-as-html/","series":null,"tags":["Visual Studio Code"],"title":"Visual Studio Code 將其他後綴的文件當成 HTML 文件"},{"categories":["Programing"],"content":"WSL(Ubuntu) 安裝 MySQL(MariaDB) 教程。\n安裝 $ sudo apt install mariadb-server 啟動服務 $ sudo service mysql start 配置 $ sudo mysql_secure_installation 用戶 此步驟是可選的，不過建議新增一個用戶，CLI 客戶端用 root 用戶連接時需要系統管理指令 sudo，否則會得到以下錯誤：\n ERROR 1698 (28000): Access denied for user \u0026lsquo;root\u0026rsquo;@\u0026lsquo;localhost\u0026rsquo;\n /* 創建密碼為 password 的用戶 user */ CREATE USER \u0026#39;user\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED BY \u0026#39;password\u0026#39;; /* 分配數據庫 dbname 的權限給 user */ GRANT ALL PRIVILEGES ON dbname.* TO \u0026#39;user\u0026#39;@\u0026#39;localhost\u0026#39;; ","date":"2019-12-12","permalink":"https://razonyang.com/zh-tw/posts/wsl/ubuntu-mysql/","series":null,"tags":["MariaDB","MySQL","Ubuntu","WSL"],"title":"WSL(Ubuntu) 安裝 MySQL(MariaDB)"},{"categories":["Programing"],"content":"一般地，PHP 項目需要搭配 Web 服務器一起使用，如最常見的 NGINX 或 Apache。但有些時候，如果急切需要搭建一個 PHP Web 運行環境，但是又沒有已安裝好的 Web 服務器，此時就輪到 PHP 內置的服務器登場了。\n也正因為 PHP 內置服務器可以提供一個便捷 Web 開發環境，很多框架都有提供相應的命令行，如：Yii 的 yii serve、Laravel 的 artisan serve。雖然十分方便，當然也有需要注意的點。\n用法 首先自然是介紹用法：\n$ php -S localhost:2333 [-t html] [-c php.ini] [router.php]  -S 指定服務器的 Domain/IP 和端口 -t 指定根目錄，默認為當前目錄，其默認會執行 index.php 或 index.html，如果沒有這兩個文件，則會返回 404 -c 指定配置文件 router.php 自定義路由  例子 緊接著開始運行我們的 PHP 內置服務器：\n1.啟動服務\n$ php -S localhost:2333 PHP 7.3.4 Development Server started at Fri Apr 26 16:57:36 2019 Listening on http://localhost:2333 Document root is /home/razon/html Press Ctrl-C to quit. 2.測試\n$ echo \u0026#34;\u0026lt;?php\\necho \u0026#39;hello world\u0026#39;;\u0026#34; \u0026gt; index.php $ curl http://localhost:2333 hello world 路由 如果定義了路由，其會接收所有的請求並處理，PHP 將根據路由返回的結果進行下一步操作。\n如果返回 false，那麼將直接返回請求的文件，否則將返回輸出的內容。\n\u0026lt;?php if (preg_match(\u0026#39;/\\.(?:png|jpg|jpeg|gif)$/\u0026#39;, $_SERVER[\u0026#34;REQUEST_URI\u0026#34;])) { // 如果是靜態文件，則直接返回  return false; } // 其他請求交由 index.php 處理 require __DIR__ . \u0026#39;/index.php\u0026#39;; 注意 雖然 PHP 內置服務器十分便捷，但是也有需要注意的點：\n 不能用於生產環境 不能併發處理請求，正因為如此，如果出現了併發問題，我們很難去尋找問題的根源  併發  The web server runs only one single-threaded process, so PHP applications will stall if a request is blocked. —— PHP built-in web server\r 從官方文檔可以知道，PHP 內置服務器是單線程的進程，其不支持併發處理。\n總結 儘管內置服務器十分便利，但是由於其不能併發處理請求，這使得其主要用於簡單的情景。複雜的情景，很可能導致更多的問題。\n相關內容  Built-in web server\r ","date":"2019-12-01","permalink":"https://razonyang.com/zh-tw/posts/php/built-in-server/","series":null,"tags":["PHP"],"title":"PHP 內置的服務器"},{"categories":["Programing"],"content":"編寫一個 SQL 查詢來重新格式化表，使得新的表中有一個部門 id 列和一些對應每個月的收入（revenue）列。\n部門表 Department：\n   Column Name Type     id int   revenue int   month varchar    (id, month) 是表的聯合主鍵。\n這個表格有關於每個部門每月收入的信息。\n月份（month）可以取下列值 [\u0026ldquo;Jan\u0026rdquo;,\u0026ldquo;Feb\u0026rdquo;,\u0026ldquo;Mar\u0026rdquo;,\u0026ldquo;Apr\u0026rdquo;,\u0026ldquo;May\u0026rdquo;,\u0026ldquo;Jun\u0026rdquo;,\u0026ldquo;Jul\u0026rdquo;,\u0026ldquo;Aug\u0026rdquo;,\u0026ldquo;Sep\u0026rdquo;,\u0026ldquo;Oct\u0026rdquo;,\u0026ldquo;Nov\u0026rdquo;,\u0026ldquo;Dec\u0026rdquo;]。\n查詢結果格式如下面的示例所示：\nDepartment 表：\n   id revenue month     1 8000 Jan   2 9000 Jan   3 10000 Feb   1 7000 Feb   1 6000 Mar    查詢得到的結果表：\n   id Jan_Revenue Feb_Revenue Mar_Revenue \u0026hellip; Dec_Revenue     1 8000 7000 6000 \u0026hellip; null   2 9000 null null \u0026hellip; null   3 null 10000 null \u0026hellip; null    注意，結果表有 13 列 (1個部門 id 列 + 12個月份的收入列)。\n解答 SELECT id, SUM(IF(month=\u0026#34;Jan\u0026#34;, revenue, null)) as Jan_Revenue, SUM(IF(month=\u0026#34;Feb\u0026#34;, revenue, null)) as Feb_Revenue, SUM(IF(month=\u0026#34;Mar\u0026#34;, revenue, null)) as Mar_Revenue, SUM(IF(month=\u0026#34;Apr\u0026#34;, revenue, null)) as Apr_Revenue, SUM(IF(month=\u0026#34;May\u0026#34;, revenue, null)) as May_Revenue, SUM(IF(month=\u0026#34;Jun\u0026#34;, revenue, null)) as Jun_Revenue, SUM(IF(month=\u0026#34;Jul\u0026#34;, revenue, null)) as Jul_Revenue, SUM(IF(month=\u0026#34;Aug\u0026#34;, revenue, null)) as Aug_Revenue, SUM(IF(month=\u0026#34;Sep\u0026#34;, revenue, null)) as Sep_Revenue, SUM(IF(month=\u0026#34;Oct\u0026#34;, revenue, null)) as Oct_Revenue, SUM(IF(month=\u0026#34;Nov\u0026#34;, revenue, null)) as Nov_Revenue, SUM(IF(month=\u0026#34;Dec\u0026#34;, revenue, null)) as Dec_Revenue FROM Department GROUP BY id  也可以用 CASE WHEN THEN。\n 原題 來源：力扣（LeetCode）\n鏈接：https://leetcode-cn.com/problems/reformat-department-table\r","date":"2019-10-22","permalink":"https://razonyang.com/zh-tw/posts/leetcode/database/reformat-department-table/","series":null,"tags":["LeetCode","MySQL"],"title":"LeetCode 數據庫面試題 – 重新格式化部門表"},{"categories":["Programing"],"content":"給定一個 Weather 表，編寫一個 SQL 查詢，來查找與之前（昨天的）日期相比溫度更高的所有日期的 Id。\n   Id(INT) RecordDate(DATE) Temperature(INT)     1 2015-01-01 10   2 2015-01-02 25   3 2015-01-03 20   4 2015-01-04 30    例如，根據上述給定的 Weather 表格，返回如下 Id:\n   Id     2   4    解答 SELECT w1.Id FROM Weather w1 LEFT JOIN Weather w2 ON DATEDIFF(w1.RecordDate, w2.RecordDate) = 1 WHERE w2.Id IS NOT NULL AND w1.Temperature \u0026gt; w2.Temperature 原題 來源：力扣（LeetCode）\n鏈接：https://leetcode-cn.com/problems/rising-temperature\r","date":"2019-10-06","permalink":"https://razonyang.com/zh-tw/posts/leetcode/database/rising-temperature/","series":null,"tags":["LeetCode","MySQL"],"title":"LeetCode 數據庫面試題 – 上升的溫度"},{"categories":["Programing"],"content":"最近查閱 PHP 官方的 PDO 文檔\r，\n在 連接與連接管理\r發現個有趣的配置：持久化連接。\n這一看，感覺像似連接池的東西，腦海中一下子就浮現好幾個問題：\n 持久連接不是可以減少建立數據庫連接所產生的消耗，以到達複用連接，提高性能的目的嗎，為啥沒有默認設置呢？ 持久連接可以設置最大連接數嗎？ 是否存在事務和死鎖問題呢？若有應該如何避免呢？  對於第一個問題，待討論完其餘問題後，答案自然浮現。\n 由於筆者知識面和深度有限，本文並不能系統且完整地闡述和解釋所有問題，亦難免會有不嚴謹或錯誤的地方，還望指出和討論。\n 環境  PHP：7.2 ZTS PDO Driver：MySQL  本文腳本已上傳在 Github\r，有興趣的可以 clone 下來親自嘗試。\n最大連接數 經常一番查找和搜索，並沒有最大連接數的配置，那麼 PHP 是怎麼維持持久連接的呢？首先想到的猜測是：每個進程/線程維持著一個持久連接，於是乎筆者寫了兩個腳本進行驗證。\n進程  需要安裝 pcntl 擴展。\n $ php pdo/persistent-process.php Process #12516 connection ID: 107 Process #12516 connection ID: 107 Process #12516 connection ID: 107 Process #12517 connection ID: 108 Process #12517 connection ID: 108 Process #12517 connection ID: 108 Child process #12516 exited with status: 0 Child process #12517 exited with status: 0 由上述輸出可看出：相同進程的連接 ID 是相同的，也就是說不同進程間是無法複用持久連接。\n線程  需要安裝 pthreads 擴展。\n $ php pdo/persistent-thread.php Thread #140162891634432 connection ID: 105 Thread #140162891634432 connection ID: 105 Thread #140162891634432 connection ID: 105 Segmentation fault 在多線程中貌似使用持久連接會出現段錯誤。\n總結 由上述兩個腳本的輸出，可以猜測出：每個進程/線程對於相同的憑證，會維持著同一個持久連接（筆者猜測！）。\n事務與鎖 關於持久連接，筆者最關心的是事務和鎖，下面將逐一討論。\n這裡可能需要分開兩種運行模式進行討論，一種是長期運行的模式（如：守護進程），另一種是傳統的 Web 模式（每次都新建腳本實例處理請求）。\n事務 關於事務，最關心的是：上一個請求的事務如果沒有提交或者回滾，是否會影響下一個請求呢？\n傳統 Web 模式 在傳統 Web 模式，每次都是新的腳本處理請求，因為腳本結束時，如果 PDO 處於事務中，但沒有提交，PHP 會對其進行事務回滾，所以在這種情況下，並不會影響下一個請求。\n守護進程 如上述說明，PDO 連接如果在腳本結束時，會對未提交的事務進行回滾，但是在守護進程中，如果代碼實現不嚴謹，會導致數據修改沒有提交等問題。\n鎖 如果在某個持久連接中，我們加了鎖後沒有在請求結束前，將鎖釋放，將會導致死鎖。\n這是因為鎖不像事務，PDO 無法自動在腳本中進行解鎖（PDO 無法感知），而且因為是持久連接，該連接一直持有該鎖，除非連接斷開（含蓄釋放鎖）或者主動釋放。\n試想下，如果加了互斥鎖，那除了加鎖的連接，其他連接就永遠無法獲取該鎖而阻塞，此時需要人為干預或者數據庫層面解決，這後果很恐怖。\n$conn = getConnection(); $conn-\u0026gt;getPDO()-\u0026gt;exec(\u0026#39;LOCK TABLES user WRITE\u0026#39;); // do something  // forgot to release lock... 避免死鎖 除了連接斷開會含蓄釋放鎖，我們可以用 try 和 finally 主動釋放鎖：\ntry { // lock } finally { // release lock } 總結 經過上述猜想和實踐，可以粗略得出以下結論：\n 因為持久連接和進程/線程數有關，大多場景下，無法在 PHP 層面控制最大的 PDO 連接數，也側面地說明持久連接和連接池是兩個東西。 使用持久連接，需要開發者更加註意事務和鎖的使用，如果編碼不當很容易出現問題，比如：死鎖。 如果服務器和數據庫都處於內網，似乎持久連接並不是那麼有必要。  使用持久連接能減少建立連接所需要的時間以提高性能是毋庸置疑的，但是是否有必要使用持久連接，還是需要根據自身情況進行權衡的。\n以筆者看來，如果業務瓶頸不在於連接，持久連接並沒有多大收益。如果是守護進程，我們完全可以使用單例模式。\n總而言之，這個持久連接很雞肋，有點失望。\n相關鏈接  PHP PDO\r Fully Understanding PDO ATTR_PERSISTENT\r ","date":"2019-10-01","permalink":"https://razonyang.com/zh-tw/posts/php/pdo-persistent-connection/","series":null,"tags":["PDO","PHP"],"title":"PHP PDO 持久連接的一些思考和實踐"},{"categories":["Programing"],"content":"本文闡述如何在 Linux 下安裝 PHP 的多線程擴展 - pthreads\r。\n要求  筆者安裝的是 pthreads v3。\n  PHP 7.2 以上 ZTS：線程安全  由於筆者的操作系統自帶的 PHP 是非 ZTS 的，所以按照 PHP 編譯安裝詳解\r編譯安裝 PHP ZTS 版。\n安裝 安裝有兩種方式：pecl 和 源碼安裝，不過筆者嘗試過 pecl 安裝失敗，上面的 pthreads 包也是 2016 年的，所以筆者放棄 pecl 安裝方式，\n本文將使用源碼編譯安裝。\n$ git clone https://github.com/krakjoe/pthreads.git $ cd pthreads $ /usr/local/php72/bin/phpize $ ./configure --with-php-config=/usr/local/php72/bin/php-config $ make $ make install Installing shared extensions: /usr/local/php72/lib/php/extensions/no-debug-zts-20170718/  ./configure --with-php-config：--with-php-config 是可選的，但由於筆者是編譯安裝的，所以可能需要指定 PHP 的配置腳本路徑，以避免意想不到的問題。   上述 phpize、php-config 等腳本請按照自己系統的配置自行修改。\n 配置 安裝成功後，在配置文件加入一行 extension=pthreads.so，比如筆者的 CLI 配置為：/usr/local/php72/lib/php-cli.ini：\n$ vi /usr/local/php72/lib/php-cli.ini extension=pthreads.so  這裡筆者特意分開命令行和其他模式的配置文件，因為 pthreads 僅限於 CLI 模式使用。\n 驗證是否成功加載：\n$ php72 -m | grep pthreads pthreads 如果沒有輸出，則說明配置不對，請檢查配置是否正確。可以通過 php72 --ini 查看所加載的配置文件是否分正確。\n php72 是筆者自行編譯的 PHP ZTS 版腳本，請修改成你係統對應的腳本名稱。\n 自此，pthreads 安裝完成。\n","date":"2019-08-01","permalink":"https://razonyang.com/zh-tw/posts/php/pthreads/","series":null,"tags":["PHP","pthreads"],"title":"PHP pthreads 多線程擴展安裝教程"},{"categories":["Linux"],"content":"在 KDE Plasma 桌面環境無法使用 TIM，提示：\n X Error of failed request: BadWindow (invalid Window parameter)\nMajor opcode of failed request: 20 (X_GetProperty)\nResource id in failed request: 0x0\nSerial number of failed request: 10\nCurrent serial number in output stream: 10\n 解決 需要先安裝 gnome-settings-daemon 並啟動 /usr/lib/gsd-xsettings，本文以 Arch Linux 為例。\n# pacman -S gnome-settings-daemon $ /usr/lib/gsd-xsettings \u0026amp; 可以將 /usr/lib/gsd-xsettings 命令添加到 KDE 設置的自動啟動中。\n相關文章  KDE 環境完全無法使用 wine-tim\r ","date":"2019-07-21","permalink":"https://razonyang.com/zh-tw/posts/kde/tim-bad-window/","series":null,"tags":["KDE","PLASMA","TIM","Arch Linux"],"title":"KDE Plasma 無法啟動 TIM"},{"categories":["Programing"],"content":"編寫一個 SQL 查詢，查找 Person 表中所有重複的電子郵箱。\n示例：\n   Id Email     1 a@b.com\r   2 c@d.com\r   3 a@b.com\r    根據以上輸入，你的查詢應返回以下結果：\n   Email     a@b.com\r    說明：所有電子郵箱都是小寫字母。\n答案 SELECT Email FROM ( SELECT Email, count(*) as amount FROM Person GROUP BY Email ) t WHERE amount \u0026gt; 1 原題 來源：力扣（LeetCode）\n鏈接：https://leetcode-cn.com/problems/duplicate-emails\r","date":"2019-07-06","permalink":"https://razonyang.com/zh-tw/posts/leetcode/database/duplicate-emails/","series":null,"tags":["LeetCode","MySQL"],"title":"LeetCode 數據庫面試題 – 查找重複的電子郵箱"},{"categories":["Linux"],"content":"Manjaro 從 XFCE 桌面環境切換為 KDE Plasma 5。\n安裝 KDE Plasma 5 安裝 KDE Plasma 桌面環境 # pacman -S plasma kio-extras 安裝 KDE 應用 # pacman -S kdebase 或者安裝 KDE 應用全家桶：\n# pacman -S kde-applications  不過全家桶 kde-applications 有幾百個包，筆者還是喜歡按需安裝。\n 安裝顯示管理器 SDDM 是 KDE 推薦的顯示管理器。\n# pacman -S sddm # systemctl enable sddm.service --force # systemctl reboot 安裝 Manjaro 的 Plasma 配置和主題 # pacman -S manjaro-kde-settings sddm-breath-theme manjaro-settings-manager-knotifier manjaro-settings-manager-kcm 重啟 安裝完成後，我們先別刪除 XFCE ，我們需要重啟下，查看 KDE Plasma 5 是否正常運行。\n卸載 XFCE 在重啟驗證 KDE Plasma 5 正常運行後，我們需要清理 XFCE ，當然你也可以留著，可以在登錄時選擇不同的桌面環境。\n# pacman -Rsc xfce4 xfce4-goodies blueman lightdm  如果未安裝了 sddm，請自行去掉上述命令中的 lightdm 包，以免出現意外情況。\n 相關文章  Install Desktop Environments\r ","date":"2019-06-01","permalink":"https://razonyang.com/zh-tw/posts/manjaro/switch-from-xfce-to-kde-plasma/","series":null,"tags":["KDE","Manjaro","PLASMA","XFCE"],"title":"Manjaro 從 XFCE 桌面環境切換為 KDE Plasma 5"},{"categories":["Linux"],"content":"CentOS MySQL 安裝教程。\n安裝倉庫 由於 CentOS 默認的數據庫是 MariaDB，我們需要手動下載和安裝 MySQL 的倉庫。\n下載地址：https://dev.mysql.com/downloads/repo/yum/\r，比如：\n 8.0：https://repo.mysql.com//mysql80-community-release-el7-1.noarch.rpm\r 5.7：https://repo.mysql.com//mysql57-community-release-el7-11.noarch.rpm\r  $ wget https://repo.mysql.com//mysql57-community-release-el7-11.noarch.rpm # yum install mysql57-community-release-el7-11.noarch.rpm  如果需要其他版本的下載鏈接或者鏈接失效，請到官方下載頁面獲取最新的鏈接。\n 安裝 # yum install mysql-server 初始化 首先需要啟動服務：\n# systemctl start mysqld 查看臨時密碼：\n$ cat /var/log/mysqld.log | grep \u0026#34;temporary password\u0026#34; 2018-12-29T10:20:14.317126Z 1 [Note] A temporary password is generated for root@localhost: wl:\u0026gt;g!cvK3kd 初始化：\n# mysql_secure_installation  初始化會提示輸入 root 密碼，也就是上一步獲得的 wl:\u0026gt;g!cvK3kd\n 測試 $ mysql -u root -p mysql\u0026gt; select version(); +-----------+ | version() | +-----------+ | 5.7.24 | +-----------+ 1 row in set (0.00 sec) 開機啟動 # systemctl enable mysqld ","date":"2019-05-01","permalink":"https://razonyang.com/zh-tw/posts/centos/mysql/","series":null,"tags":["CentOS","MySQL"],"title":"CentOS 安裝 MySQL"},{"categories":["Programing"],"content":"SQLite 並沒有 IF 方法，不過我們可以使用 CASE WHEN 代替。\nSELECT CASE WHEN col = 1 THEN \u0026#39;foo\u0026#39; ELSE \u0026#39;bar\u0026#39; END FROM t1 也可以用於排序：\nSELECT * FROM t1 ORDER BY CASE WHEN col=1 THEN 0 ELSE 1 END ASC ","date":"2019-04-29","permalink":"https://razonyang.com/zh-tw/posts/sqlite/if/","series":null,"tags":["SQLite","if"],"title":"SQLite IF 的等效方法"},{"categories":["Programing"],"content":"小美是一所中學的信息科技老師，她有一張 seat 座位表，平時用來儲存學生名字和與他們相對應的座位 ID,其中縱列的 ID 是連續遞增的。小美想改變相鄰倆學生的座位。\n你能不能幫她寫一個 SQL query 來輸出小美想要的結果呢？\n示例：\n   id student     1 Abbot   2 Doris   3 Emerson   4 Green   5 Jeames    假如數據輸入的是上表，則輸出結果如下：\n   id student     1 Doris   2 Abbot   3 Green   4 Emerson   5 Jeames    注意：\n如果學生人數是奇數，則不需要改變最後一個同學的座位。\n分析 依題，座位 ID 是連續的，我們可以獲取前後座位的信息，並做以下處理即可：\n 當前座位 ID 為奇數，和後一個座位的同學換座。 當前座位 ID 為偶數，和前一個座位的同學換座。 如果前/後座位為空，則不換座。  解答 SELECT s.id, IFNULL(IF(s.id%2=1, n.student, p.student), s.student) as student FROM seat s LEFT JOIN seat p ON p.id = s.id-1 LEFT JOIN seat n ON n.id = s.id+1 原題 https://leetcode-cn.com/problems/exchange-seats\r","date":"2019-04-12","permalink":"https://razonyang.com/zh-tw/posts/leetcode/database/exchange-seats/","series":null,"tags":["LeetCode","MySQL"],"title":"LeetCode 數據庫面試題 – 換座位（Exchange Seats）"},{"categories":["Programing"],"content":"編寫一個 SQL 查詢，獲取 Employee 表中第二高的薪水（Salary） 。\n   Id Salary     1 100   2 200   3 300    例如上述 Employee 表，SQL查詢應該返回 200 作為第二高的薪水。如果不存在第二高的薪水，那麼查詢應返回 null。\n   SecondHighestSalary     200    答案 SELECT ( SELECT DISTINCT Salary FROM Employee ORDER BY Salary DESC LIMIT 1,1 ) as SecondHighestSalary 原題 https://leetcode-cn.com/problems/second-highest-salary\r","date":"2019-04-05","permalink":"https://razonyang.com/zh-tw/posts/leetcode/database/second-highest-salary/","series":null,"tags":["LeetCode","MySQL"],"title":"LeetCode 數據庫面試題 – 第二高的薪水（Second Highest Salary）"},{"categories":["Programing"],"content":"由於業務改動，打算在某表加上一個 id 為 0 的記錄，但是發現了個有趣的事情：id 自增了，而不是 ``。\n重現 首先新建一個測試表演示一下：\n\u0026gt; CREATE TABLE `t_user`(`id` INTEGER PRIMARY KEY AUTO_INCREMENT, `name` VARCHAR(32) NOT NULL); \u0026gt; INSERT INTO `t_user`(`id`, `name`) VALUES(0, \u0026#39;foo\u0026#39;); \u0026gt; SELECT * FROM `t_user`;    id name     1 foo    解決 可以看 id 不是所期望的 ，經過一番搜索得知，MySQL **一般情況**下，自增列在值為 `null` 或  時，其值會自增。\n既然是指一般情況下，也就是說可以修改這個默認行為，而這個配置就是 NO_AUTO_VALUE_ON_ZERO。\n按字面理解就是自增列值為 `` 時，不使用下一個序列號，我們不妨測試一下。\n\u0026gt; SET SESSION sql_mode=\u0026#34;NO_AUTO_VALUE_ON_ZERO\u0026#34;; \u0026gt; INSERT INTO `t_user`(`id`, `name`) VALUES(0, \u0026#39;bar\u0026#39;); \u0026gt; SELECT * FROM `t_user`;    id name     0 bar   1 foo    可以看到，id 終於_正常_了。\n 注意：本文例子只是臨時設置了 sql_mode，如果需要永久有效，請修改配置文件並重啟。\n另外，不建議自增列存儲零值，如果要這麼做，請確保設置了 NO_AUTO_VALUE_ON_ZERO，否則會出現意想不到的問題。\n比如將本地 mysqldump 導出數據導入到未設置 NO_AUTO_VALUE_ON_ZERO 的服務端時，就會出現數據不一致的問題。\n 相關內容  MySQL Server SQL Modes - NO_AUTO_VALUE_ON_ZERO\r How to force MySQL to take 0 as a valid auto-increment value\r ","date":"2019-04-01","permalink":"https://razonyang.com/zh-tw/posts/mysql/using-zero-value-on-auto-increment-field/","series":null,"tags":["MySQL"],"title":"MySQL 在 AUTO INCREMENT 列存儲零值"},{"categories":["Programing"],"content":"有一個courses 表 ，有: student (學生) 和 class (課程)。\n請列出所有超過或等於5名學生的課。\n例如,表:\n   student class     A Math   B English   C Math   D Biology   E Math   F Computer   G Math   H Math   I Math    應該輸出:\n   class     Math    Note:\n學生在每個課中不應被重複計算。\n解答 SELECT class FROM ( SELECT class, count(DISTINCT student) as amount FROM courses GROUP BY class ) t WHERE amount \u0026gt;= 5 原題 來源：力扣（LeetCode）\n鏈接：https://leetcode-cn.com/problems/classes-more-than-5-students\r","date":"2019-03-08","permalink":"https://razonyang.com/zh-tw/posts/leetcode/database/classes-more-than-five-students/","series":null,"tags":["LeetCode","MySQL"],"title":"LeetCode 數據庫面試題 – 超過5名學生的課"},{"categories":["Programing"],"content":"集合 S 一般包含數字 1~n，但由於數據錯誤，其中的一個數字重複了，導致缺失了某一數字。\n現給出一個數組 nums，請找出其中重複和缺失的數字。\n原題 The set S originally contains numbers from 1 to n.\nBut unfortunately, due to the data error, one of the numbers in the set got duplicated to another number in the set,\nwhich results in repetition of one number and loss of another number.\nGiven an array nums representing the data status of this set after the error.\nYour task is to firstly find the number occurs twice and then find the number that is missing. Return them in the form of an array.\nExample 1:\nInput: nums = [1,2,2,4]\rOutput: [2,3]\r Note:\n The given array size will in the range [2, 10000]. The given array\u0026rsquo;s numbers won\u0026rsquo;t have any order.  分析  正確的數組中，每個數字只出現一次，範圍[1,n] 找出重複的數字和缺失的數字  用 Map 記錄出現的數字次數，則可輕鬆地的找到重複的數字。\n至於缺失的數字，筆者暫時想到兩種方式：\n 異或，(1^1)^(2^2)^\u0026hellip;^(x)^\u0026hellip;^(n^n)，則可知道缺失的數字是x Map 是已出現了的數字集合，只需再次遍歷一遍，則可得到缺失的數字  實現 完整代碼和測試已託管在 go-algorithm\r。\n實現一 func findErrorNums(nums []int) []int { m := make(map[int]bool, len(nums)) v := make([]int, 2) for i := 0; i \u0026lt; len(nums); i++ { v[1] ^= i + 1 if m[nums[i]] { v[0] = nums[i] } else { m[nums[i]] = true v[1] ^= nums[i] } } return v } 實現二 func findErrorNums(nums []int) []int { m := make(map[int]bool, len(nums)) v := make([]int, 2) for _, num := range nums { if m[num] { v[0] = num } m[num] = true } for i := 1; i \u0026lt;= len(nums); i++ { if !m[i] { v[1] = i break } } return v } ","date":"2019-03-02","permalink":"https://razonyang.com/zh-tw/posts/leetcode/algorithm/set-mismatch/","series":null,"tags":["LeetCode","Go"],"title":"LeetCode 算法題 – Set Mismatch"},{"categories":["Programing"],"content":"編寫一個程序，用字符串表示數字 1 到 n，其中：\n 如果數字是3的倍數，則輸出Fizz 如果數字是5的倍數，則輸出Buzz 如果數字是3和5的倍數，則輸出FizzBuzz  原題 Write a program that outputs the string representation of numbers from 1 to n.\nBut for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”.\nExample:\nn = 15,\rReturn:\r[\r\u0026quot;1\u0026quot;,\r\u0026quot;2\u0026quot;,\r\u0026quot;Fizz\u0026quot;,\r\u0026quot;4\u0026quot;,\r\u0026quot;Buzz\u0026quot;,\r\u0026quot;Fizz\u0026quot;,\r\u0026quot;7\u0026quot;,\r\u0026quot;8\u0026quot;,\r\u0026quot;Fizz\u0026quot;,\r\u0026quot;Buzz\u0026quot;,\r\u0026quot;11\u0026quot;,\r\u0026quot;Fizz\u0026quot;,\r\u0026quot;13\u0026quot;,\r\u0026quot;14\u0026quot;,\r\u0026quot;FizzBuzz\u0026quot;\r]\r 實現 實現一 func fizzBuzz(n int) []string { ret := make([]string, n) for i := 1; i \u0026lt;= n; i++ { if i%15 == 0 { ret[i-1] = \u0026#34;FizzBuzz\u0026#34; } else if i%5 == 0 { ret[i-1] = \u0026#34;Buzz\u0026#34; } else if i%3 == 0 { ret[i-1] = \u0026#34;Fizz\u0026#34; } else { ret[i-1] = strconv.Itoa(i) } } return ret } 實現二 func fizzBuzz(n int) []string { ret := make([]string, n) three := 3 five := 5 fifteen := 15 for i := 1; i \u0026lt;= n; i++ { if i == fifteen { ret[i-1] = \u0026#34;FizzBuzz\u0026#34; fifteen += 15 five += 5 three += 3 } else if i == five { ret[i-1] = \u0026#34;Buzz\u0026#34; five += 5 } else if i == three { ret[i-1] = \u0026#34;Fizz\u0026#34; three += 3 } else { ret[i-1] = strconv.Itoa(i) } } return ret }  經過測試，兩個版本的性能差不多。\n","date":"2019-03-02","permalink":"https://razonyang.com/zh-tw/posts/leetcode/algorithm/fizz-buzz/","series":null,"tags":["LeetCode","Go"],"title":"LeetCode 算法題 – Fizz Buzz"},{"categories":["Programing"],"content":"前段時間，想嘗試下 PHP 的多線程擴展 pthreads\r，由於其要求 PHP 啟用 ZTS （Zend Thread Safety），\n但是筆者所使用的發行版所能安裝的 PHP 包都是 non-zts 的，所以只能自行編譯和安裝 PHP 了。\n 題外話，貌似基本大多數 Linux 發行版的 PHP 包都是 non-zts 的，比如 Ubuntu、CentOS、Arch Linux 等。\n不過據我所知，Arch Linux AUR 有 ZTS 版本的 PHP，傳送門可在本文底部相關鏈接\r找到。\n另外 Gentoo 的話，PHP 默認是 ZTS 的。\n 話不多說，讓我們開始正題。\n下載 首先需要下載 PHP 的源碼包 - 下載地址\r。\n 本文以最新的 PHP 版本 - 7.2 為例，題外話：pthreads(v3) 只能在 PHP 7.2 使用。\n $ wget -O php-7.2.12.tar.gz http://cn2.php.net/get/php-7.2.12.tar.gz/from/this/mirror $ tar xvf php-7.2.12.tar.gz $ cd php-7.2.12  wget -O 指定寫入（下載）的文件名稱  這裡我們下載和解壓 PHP 的源碼，並進入解壓後的 PHP 目錄，下一步編譯時，需要在此目錄進行操作。\n編譯 接下來就是編譯\n編譯參數 我們可以通過以下命令，查看目標版本支持的所有編譯參數：\n$ ./configure --help 這裡就不詳盡介紹所有的參數了，本文只對一些重要的信息進行說明：\n --prefix：最終安裝的 PHP 目錄，比如 /usr/local，由於筆者一般會使用多個 PHP 版本，目錄一般會帶上主次版本號，比如本文所使用到的：/usr/local/php72 --enable-maintainer-zts：啟用 ZTS - 線程安全，必要參數 --enable-fpm：啟用 PHP-FPM --with-gd：啟用 GD 庫 --enable-pcntl：PHP 多進程擴展，適用於 *nix 系統 --with-pdo-mysql：MySQL PDO 驅動  本文以以下配置進行 PHP 編譯，請根據需要自行增刪：\n$ ./configure \\  --prefix=/usr/local/php72 \\  --enable-maintainer-zts \\  --enable-fpm \\  --with-gd --with-freetype \\  --enable-pcntl \\  --with-pdo-mysql --with-mysqli \\  --with-mcrypt \\  --enable-soap \\  --enable-sockets \\  --enable-pcntl \\  --enable-intl  配置期間，會檢測系統的依賴，由於筆者 Linux 發行版已安裝了自帶的 PHP，所有依賴基本都自行解決了，所以無需額外安裝其他依賴。\n由於依賴因配置、系統的不同（不同發行版有著其自己的包管理方式，比如 apt、yum、emerge、pacman etc\u0026hellip;）而解決方法不同，所以如果遇到編譯錯誤或者缺少依賴，請自行 Google 解決。\n 安裝 緊接著，安裝：\n$ make \u0026amp;\u0026amp; make install 在 make install 之前，你也可以進行測試 make test（可選）。\nmake install 可能需要 root 權限，鑑於要寫入到之前編譯配置的 --prefix 目錄。\n 如果修改了編譯配置，你可能需要 make clean，然後再安裝。\n 驗證安裝 $ /usr/local/php72/bin/php -v PHP 7.2.12 (cli) (built: Nov 29 2018 14:57:26) ( ZTS ) Copyright (c) 1997-2018 The PHP Group Zend Engine v3.2.0, Copyright (c) 1998-2018 Zend Technologies 其中會有 ZTS 字眼，說明我們安裝的是線程安全版。\n配置文件 安裝完成後，先複製一下配置文件，這裡筆者將配置文件分開兩個，一個專用於 CLI 模式。因為 CLI 和其他模式可能會有一絲差異，比如 pthreads 僅限於 CLI 模式使用。\n$ cp ./php.ini-development /usr/local/php72/lib/php.ini $ cp ./php.ini-development /usr/local/php72/lib/php-cli.ini  如果打算配置的是生產環境，將 php.ini-development 替換為 php.ini-production 即可。\n 測試命令行模式是否加載到正確的配置文件：\n$ /usr/local/php72/bin/php --ini Configuration File (php.ini) Path: /usr/local/php72/lib Loaded Configuration File: /usr/local/php72/lib/php-cli.ini Scan for additional .ini files in: (none) Additional .ini files parsed: (none) 軟連接 自此，我們已經完成 PHP 編譯安裝，最後為新安裝的 PHP 腳本建立軟連接，這樣就不需要每次那麼繁瑣地輸入腳本的完整路徑了：\n$ ln -s /usr/local/php72/bin/php /usr/local/bin/php72 接著驗證是否有效：\n$ php72 -v 相關鏈接  Arch Linux AUR - PHP ZTS\r ","date":"2019-02-22","permalink":"https://razonyang.com/zh-tw/posts/php/compilation/","series":null,"tags":["PHP"],"title":"PHP 編譯安裝詳解"},{"categories":["Programing"],"content":"用一條 UPDATE 語句，在不使用中間臨時表的情況下，將 salary 表中 sex 的值反轉。\n原題 Given a table salary, such as the one below, that has m=male and f=female values. Swap all f and m values (i.e., change all f values to m and vice versa) with a single update query and no intermediate temp table.\nFor example:\n   id name sex salary     1 A m 2500   2 B f 1500   3 C m 5500   4 D f 500    After running your query, the above salary table should have the following rows:\n   id name sex salary     1 A f 2500   2 B m 1500   3 C f 5500   4 D m 500    SQL UPDATE salary SET sex = IF(sex=\u0026#39;f\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;f\u0026#39;); OR\nUPDATE salary SET sex = CASE sex WHEN \u0026#39;f\u0026#39; THEN \u0026#39;m\u0026#39; ELSE \u0026#39;f\u0026#39; END; ","date":"2019-02-02","permalink":"https://razonyang.com/zh-tw/posts/leetcode/database/swap-salary/","series":null,"tags":["LeetCode","MySQL"],"title":"LeetCode 數據庫面試題 – 交換工資（Swap Salary）"},{"categories":["Programing"],"content":"NGINX 反向代理 WebSocket 配置說明。\n配置 # 定義 WebSocket Upstream upstream websocket { server 127.0.0.1:2333; } server { # ...  # 代理 WebSocket 請求  location /ws/ { proxy_pass http://websocket; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \u0026#34;Upgrade\u0026#34;; } # ... } 相關資料  NGINX as a WebSocket Proxy\r ","date":"2019-02-01","permalink":"https://razonyang.com/zh-tw/posts/nginx/websocket-proxy/","series":null,"tags":["Nginx","Proxy","Websocket"],"title":"NGINX 反向代理 WebSocket"},{"categories":["Programing"],"content":"Docker 運行多個命令。\nDocker run $ docker run image:tag /bin/bash -c \u0026#34;cmd1 \u0026amp;\u0026amp; cmd2\u0026#34; Docker compose services: db: commands: /bin/bash -c \u0026#34;cmd1 \u0026amp;\u0026amp; cmd2\u0026#34; ","date":"2019-02-01","permalink":"https://razonyang.com/zh-tw/posts/docker/execute-multiple-commands/","series":null,"tags":["Docker"],"title":"Docker 運行多個命令"},{"categories":["Programing"],"content":"WordPress 的 Nginx 配置示例。\n# Upstream to abstract backend connection(s) for php upstream php { server unix:/tmp/php-cgi.socket; server 127.0.0.1:9000; } server { ## Your website name goes here.  server_name domain.tld; ## Your only path reference.  root /var/www/wordpress; ## This should be in your http block and if it is, it\u0026#39;s not needed here.  index index.php; location = /favicon.ico { log_not_found off; access_log off; } location = /robots.txt { allow all; log_not_found off; access_log off; } location / { # This is cool because no php is touched for static content.  # include the \u0026#34;?$args\u0026#34; part so non-default permalinks doesn\u0026#39;t break when using query string  try_files $uri $uri/ /index.php?$args; } location ~ \\.php$ { #NOTE: You should have \u0026#34;cgi.fix_pathinfo = 0;\u0026#34; in php.ini  include fastcgi.conf; fastcgi_intercept_errors on; fastcgi_pass php; } location ~* \\.(js|css|png|jpg|jpeg|gif|ico)$ { expires max; log_not_found off; } } ","date":"2019-01-20","permalink":"https://razonyang.com/zh-tw/posts/wordpress/nginx-configuration/","series":null,"tags":["WordPress","Nginx"],"title":"WordPress Nginx 配置"},{"categories":["Programing"],"content":"本文將簡述如何快速瞭解 PHP 的多進程編程，並提供實驗腳本。\n函數 為快速入門，本文只使用多進程的兩個函數：pcntl_fork\r和 pcntl_waitpid\r多進程開發最重要的函數 pcntl_fork，其在當前進程 fork 一個子進程，然後父子進程在 fork 處分別繼續向下執行。\n這裡需要注意，pcntl_fork 返回的值在父進程會得到子進程的 PID （進程 ID），而在子進程中，該值為 ``。\n實例 接著開始實踐，執行 pcntl.php\r腳本：\n$ php ./pcntl.php Child process #7217 started Child process #7218 started Child process #7218 finished Child process #7220 started Child process #7221 started Child process #7219 started Child process #7221 finished Child process #7217 finished Child process #7220 finished Child process #7219 finished Child process #7217 exited with status: 0 Child process #7218 exited with status: 0 Child process #7219 exited with status: 0 Child process #7220 exited with status: 0 Child process #7221 exited with status: 0 pcntl.php \u0026lt;?php if (!extension_loaded(\u0026#39;pcntl\u0026#39;)) { die(\u0026#34;Extension not loaded: pcntl\\n\u0026#34;); } $workers = []; $workersCount = 5; for ($i = 0; $i \u0026lt; $workersCount; $i++) { $pid = pcntl_fork(); if ($pid \u0026lt; 0) { die(\u0026#34;Could not fork\\n\u0026#34;); } if ($pid \u0026gt; 0) { // parent process  $workers[] = $pid; // store child process ID.  continue; } // child process  $pid = posix_getpid(); echo \u0026#34;Child process #{$pid}started\\n\u0026#34;; // task  sleep(rand(0, 2)); echo \u0026#34;Child process #{$pid}finished\\n\u0026#34;; // exit on child process has finished it\u0026#39;s task.  exit(0); } // parent process foreach ($workers as $worker) { // wait child process to exit  pcntl_waitpid($worker, $status); echo \u0026#34;Child process #{$worker}exited with status: {$status}\\n\u0026#34;; } ","date":"2019-01-06","permalink":"https://razonyang.com/zh-tw/posts/php/pcntl-primer/","series":null,"tags":["PHP","pcntl"],"title":"PHP 多進程編程 – 入門"},{"categories":["Programing"],"content":"本文將闡述如何用PHP以正確的姿勢獲取URL的信息，並將其封裝成類，方便複用。\nURL 首先來了解一下URL的文法：\nscheme:[//[user[:password]@]host[:port]][/path][?query][#fragment]\r  中括號表示的是可選項。\n    Name Explanation     scheme 傳輸協議   user, password 訪問資源需要的憑證信息   host 服務器   port 端口   path 路徑   query 查詢   fragment 片段     hierarchical part\r┌───────────────────┴─────────────────────┐\rauthority path\r┌───────────────┴───────────────┐┌───┴────┐\rabc://username:password@example.com:123/path/data?key=value\u0026amp;key2=value2#fragid1\r└┬┘ └───────┬───────┘ └────┬────┘ └┬┘ └─────────┬─────────┘ └──┬──┘\rscheme user information host port query fragment\rurn:example:mammal:monotreme:echidna\r└┬┘ └──────────────┬───────────────┘\rscheme path\r函數 在瞭解URL的文法之後，我們很容易編寫函數去獲取URL的信息，但是本文並不打算編寫獨立的函數，\n因為PHP已經提供了內置的函數 parse_url 和 parse_str 來實現這一目的。\nparse_url mixed parse_url ( string $url [, int $component = -1 ] ) parse_url 解析一個URL，並返回一個包含URL各種組成部分的關聯數組（鍵名和URL文法中的一致，比如：scheme、host、port等）。\n當指定了第二個參數 component，則會返回指定組成部分的值，此時返回的是字符串或者數值（PHP_URL_PORT）。\n官方文檔：https://secure.php.net/manual/zh/function.parse-url.php\rparse_str void parse_str ( string $encoded_string [, array \u0026amp;$result ] ) parse_str 將字符串解析成多個變量，第二個參數 $result 用於存儲變量的鍵值。\n這裡有點小疑惑，因為可以看到 $result 是可選的，且該函數沒有返回值，如果不設置 $result，那麼這函數的意義是什麼呢？\n不過官方文檔也標註了：極度不建議不設置 $result 的情況下使用該函數，並且在 PHP 7.2 中將廢棄不設置參數的行為。\n官方文檔：https://secure.php.net/manual/zh/function.parse-str.php\r實現 通過上述的 parse_url 和 parse_str 函數，可以輕鬆的獲取URL的信息：\n// URL $url = \u0026#39;https://example.com/user?name=foo\u0026#39;; // 獲取URL組成部分 $components = parse_url($url); print_r($components); // 獲取查詢字符串 $query = isset($components[\u0026#39;query\u0026#39;]) ? $components[\u0026#39;query\u0026#39;] : \u0026#39;\u0026#39;; print_r($query); // 獲取查詢參數數組 parse_str($query, $params); print_r($params); 輸出\n Array\r(\r[scheme] =\u0026gt; https\r[host] =\u0026gt; example.com\r[path] =\u0026gt; /user\r[query] =\u0026gt; name=foo\r)\rname=foo\rArray\r(\r[name] =\u0026gt; foo\r)\rClass 最後，將此封裝成類，方便複用。\n/** * Class URL * * @property string|null scheme * * @property string|null user * * @property string|null pass * * @property string|null host * * @property integer|null port * * @property string|null path * * @property string|null query * * @property string|null fragment */ class URL { private $data; private $queryParams; public function __construct($url) { $this-\u0026gt;data = parse_url($url); if ($this-\u0026gt;data === false) { throw new \\InvalidArgumentException(\u0026#34;invalid } } public function __get($name) { return isset($this-\u0026gt;data[$name]) ? $this-\u0026gt;data[$name] : null; } public function getQueryParams() { if ($this-\u0026gt;queryParams=== null) { $query= $this-\u0026gt;query; if (empty($query)) { $this-\u0026gt;queryParams= []; } else { parse_str($query, $this-\u0026gt;queryParams); } } return $this-\u0026gt;queryParams; } } ","date":"2018-12-21","permalink":"https://razonyang.com/zh-tw/posts/php/retrieve-url-info/","series":null,"tags":["PHP"],"title":"PHP 獲取 URL 信息"},{"categories":["Programing"],"content":"Employee 表包含所有員工，他們的經理也屬於員工。每個員工都有一個 Id，此外還有一列對應員工的經理的 Id。\n   Id Name Salary ManagerId     1 Joe 70000 3   2 Henry 80000 4   3 Sam 60000 NULL   4 Max 90000 NULL    給定 Employee 表，編寫一個 SQL 查詢，該查詢可以獲取收入超過他們經理的員工的姓名。在上面的表格中，Joe 是唯一一個收入超過他的經理的員工。\n   Employee     Joe    解答 SELECT e.Name as Employee FROM Employee e LEFT JOIN Employee m ON m.Id = e.ManagerId WHERE e.Salary \u0026gt; m.Salary 原題 來源：力扣（LeetCode）\n鏈接：https://leetcode-cn.com/problems/employees-earning-more-than-their-managers\r","date":"2018-12-06","permalink":"https://razonyang.com/zh-tw/posts/leetcode/database/employees-earning-more-than-their-managers/","series":null,"tags":["LeetCode","MySQL"],"title":"LeetCode 數據庫面試題 – 超過經理收入的員工"},{"categories":["Linux"],"content":"CentOS 官方倉庫的 PHP 版本是 5.4，但此版本已經不再被官方支持，考慮到安全問題和更好的性能，我們有必要安裝或升級更高版本的 PHP，比如最新的 7.2。\n那麼我們進入正文，首先我們需要安裝 EPEL 和 Remi，至於這兩個是什麼，有興趣的童鞋可以在相關鏈接進行查閱。\n倉庫 安裝 EPEL # yum install epel-release 安裝 Remi # yum install https://rpms.remirepo.net/enterprise/remi-release-7.rpm 啟用 PHP 倉庫 # yum-config-manager --enable remi-php72 你也可以選擇其他版本，如：remi-php56，remi-php70，remi-php71。\n 如果 yum-config-manager 命令不存在，你需要安裝 yum-utils：yum -y install yum-utils。\n 安裝或升級 安裝 PHP # yum install php 升級 PHP # yum update 相關鏈接  Extra Packages for Enterprise Linux\r What is Remi repository\r Install PHP 7 on CentOS, RHEL or Fedora\r ","date":"2018-12-01","permalink":"https://razonyang.com/zh-tw/posts/centos/install-or-upgrade-to-php7/","series":null,"tags":["CentOS","PHP","PHP7"],"title":"CentOS 安裝或升級到 PHP 7"},{"categories":["Programing"],"content":"之前經常看到 URI、URL 和 URN，但是都沒去理清這三者的關係，於是今天就花了點時間搞清楚三者關係。\n含義 先了解一下三者的含義\nURI URI - 統一資源標識符（Uniform Resource Identifier），是一個用於標識某一互聯網資源名稱的字符串。\nURL URL - 統一資源定位符（或稱統一資源定位器/定位地址、URL地址，英語：Uniform Resource Locator，常縮寫為URL），有時也被俗稱為網頁地址（網址）。\nURN URN - 統一資源名稱（Uniform Resource Name），是統一資源標識（URI）的歷史名字。\n關係  URI可被視為定位符（URL），名稱（URN）或兩者兼備。統一資源名（URN）如同一個人的名稱，而統一資源定位符（URL）代表一個人的住址。\n換言之，URN定義某事物的身份，而URL提供查找該事物的方法。\n URL方案分類圖\n URL(定位符) 和 URN(名稱) 方案屬於 URI 的子類，URI 可以為 URL 或 URN 兩者之一或同時是 URI 和 URN。技術上講，URL 和 URN 屬於資源ID；\n但是，人們往往無法將某種方案歸類於兩者中的某一個：所有的URI都可被作為名稱看待，而某些方案同時體現了兩者中的不同部分。\n 延伸閱讀  統一資源標誌符\r 統一資源定位符\r 統一資源名稱\r What is the difference between a URI, a URL and a URN?\r ","date":"2018-11-30","permalink":"https://razonyang.com/zh-tw/posts/http/uri-url-urn/","series":null,"tags":["URI","URL","URN"],"title":"URI、URL 和 URN 之間的關係和區別"},{"categories":["Programing"],"content":"前些天筆者想開啟 Github 的短信方式的雙重驗證(two factor authentication)，但是發現並沒有我們天朝的區號(86)，難道是 Github 不支持國內的短信雙重驗證嗎？其實不然。\n因為手機區號選擇是一個 select 列表，筆者想著可不可以自己加一個選項呢？\n實踐是檢驗真理的唯一標準，我用瀏覽器自帶的審查元素功能，然後編輯 select 列表，然後添加以下選項：\n\u0026lt;option value=\u0026#34;+86\u0026#34;\u0026gt;China +86\u0026lt;/option\u0026gt; 接著選中，填寫號碼，結果居然成功設定了，這似乎是 Github 故意隱藏或者忽略了。\n","date":"2018-09-08","permalink":"https://razonyang.com/zh-tw/posts/github/enable-two-factor-authentication/","series":null,"tags":["GitHub","HTML"],"title":"Github 開啟短信雙重驗證"},{"categories":["Programing"],"content":"移除元素：\n 移除整數數組中值與給定數字相等的元素，並返回其最終的長度 不能分配額外的內存  原題 Given an array and a value, remove all instances of that value in place and return the new length.\nDo not allocate extra space for another array, you must do this in place with constant memory.\nThe order of elements can be changed. It doesn\u0026rsquo;t matter what you leave beyond the new length.\nExample:\nGiven input array nums = [3,2,2,3], val = 3\nYour function should return length = 2, with the first two elements of nums being 2.\n分析 本題難度低，主要的為題是不能分配額外的內存，所以需要在原數組進行修改，那麼接下來就很簡單了，\n遍歷數組，將和給定數值相等的元素移除即可。\n實現 func removeElement(nums []int, val int) int { for i := 0; i \u0026lt; len(nums); { if nums[i] == val { // remove current element from nums,  // and the next element\u0026#39;s index is i, not i++.  nums = append(nums[:i], nums[i+1:]...) } else { i++ } } return len(nums) } ","date":"2018-09-02","permalink":"https://razonyang.com/zh-tw/posts/leetcode/algorithm/remove-element/","series":null,"tags":["LeetCode","Go"],"title":"LeetCode 算法題 – Remove Element"},{"categories":["Programing"],"content":"某網站包含兩個表，Customers 表和 Orders 表。編寫一個 SQL 查詢，找出所有從不訂購任何東西的客戶。\nCustomers 表：\n   1 Joe     2 Henry   3 Sam   4 Max    Orders 表：\n   Id CustomerId     1 3   2 1    例如給定上述表格，你的查詢應返回：\n   Customers     Henry   Max    解答 SELECT Name as Customers FROM Customers WHERE Id NOT IN ( SELECT DISTINCT CustomerId FROM Orders ) 原題 來源：力扣（LeetCode）\n鏈接：https://leetcode-cn.com/problems/customers-who-never-order\r","date":"2018-08-26","permalink":"https://razonyang.com/zh-tw/posts/leetcode/database/customers-who-never-order/","series":null,"tags":["LeetCode","MySQL"],"title":"LeetCode 數據庫面試題 – 從不訂購的客戶"},{"categories":["Programing"],"content":"編寫一個 function 獲取兩個數值數組的交集，交集中數值唯一。\n原題 Given two arrays, write a function to compute their intersection.\nExample:\nGiven nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2].\nNote:\n Each element in the result must be unique. The result can be in any order.  分析  數值唯一 順序隨意  實現 func intersection(nums1 []int, nums2 []int) []int { m := make(map[int]bool) for _, num := range nums1 { m[num] = true } var v []int for _, num := range nums2 { if m[num] { v = append(v, num) delete(m, num) } } return v } ","date":"2018-08-02","permalink":"https://razonyang.com/zh-tw/posts/leetcode/algorithm/interseion-of-two-arrays/","series":null,"tags":["LeetCode","Go"],"title":"LeetCode 算法題 – Intersection of Two Arrays"},{"categories":["Programing"],"content":"現給出一個已排序（升序）的數組和一個 target 值，如果找到該 target，則返回其所在數組的索引。\n如果沒有找到，則按照升序，返回 target 應被插入的位置。\n你可以假定數組沒有重複的值。\n原題 Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\nYou may assume no duplicates in the array.\nHere are few examples.\n [1,3,5,6], 5 → 2 [1,3,5,6], 2 → 1 [1,3,5,6], 7 → 4 [1,3,5,6], 0 → 0  分析  數組按升序排序 找到：如果 target 與某數值相等，則返回該數值所在的數組的索引 插入：如果 target 比某數值小，則返回該數值所在數組的索引  實現 func searchInsert(nums []int, target int) int { for idx, num := range nums { if num \u0026gt;= target { return idx } } return len(nums) } ","date":"2018-06-22","permalink":"https://razonyang.com/zh-tw/posts/leetcode/algorithm/search-insert-position/","series":null,"tags":["LeetCode","Go"],"title":"LeetCode 算法題 – Search Insert Position"},{"categories":["Programing"],"content":"最近將數據庫服務遷移到阿里雲的 RDS（MySQL 5.7） 時出現錯誤：\n Specified key was too long; max key length is 767 bytes\n 只需要修改參數 innodb_large_prefix 為 ON 即可。\n","date":"2018-06-09","permalink":"https://razonyang.com/zh-tw/posts/aliyun/rds-mysql-specified-key-was-too-long/","series":null,"tags":["MySQL","Aliyun"],"title":"阿里雲 RDS MySQL 5.7 Specified key was too long; max key length is 767 bytes"},{"categories":["Programing"],"content":"編寫一個 SQL 查詢，來刪除 Person 表中所有重複的電子郵箱，重複的郵箱裡只保留 Id 最小 的那個。\n   Id Email     2 bob@example.com\r   3 john@example.com\r    Id 是這個表的主鍵。\n例如，在運行你的查詢語句之後，上面的 Person 表應返回以下幾行:\n   Id Email     1 john@example.com\r   2 bob@example.com\r     提示：\n 執行 SQL 之後，輸出是整個 Person 表。 使用 delete 語句。  解答 自連接 DELETE p1 FROM Person p1, Person p2 WHERE p1.Email = p2.Email AND p1.Id \u0026gt; p2.Id WHERE NOT IN DELETE FROM Person WHERE Id NOT IN ( SELECT * FROM ( SELECT min(Id) as Id FROM Person GROUP BY Email ) temp ) WHERE NOT IN 要用臨時表，MySQL 不允許直接在原表子查詢，否則會出現錯誤：\n You can\u0026rsquo;t specify target table \u0026lsquo;Person\u0026rsquo; for update in FROM clause\n 原題 https://leetcode-cn.com/problems/delete-duplicate-emails\r","date":"2018-06-05","permalink":"https://razonyang.com/zh-tw/posts/leetcode/database/remove-duplicate-emails/","series":null,"tags":["LeetCode","MySQL"],"title":"LeetCode 數據庫面試題 – 刪除重複的電子郵箱（Remove Duplicate Emails）"},{"categories":["Programing"],"content":"如題所示，本文為Vim入門教程，文章涵蓋Vim基本的操作：插入、替換、刪除、搜索、修改、撤銷、重做等等，以及筆者個人的理解和說明。\n光標移動 方向鍵  k\rh l\rj\r光標移動的方向鍵是hjkl，當然還有默認的方向鍵。要記住hjkl其實很容易，以j為中心：\n   Command Description     j 形似下箭頭，使光標向下移動。   h 位於左邊，使光標向左移動。   l 位於右邊，使光標向右移動。   k 使光標向上移動。    其他    Command Description     0 使光標移動至行首。   $ 使光標移動至行尾部，可記作end of line。   xw 使光標移動x個單詞，w可記作word，比如2w，使光標移動兩個單詞，並位於第二個單詞的首個字符處。   xe 使光標移動x個單詞，e可記作end of word，這個和xw相似，區別是移動後，光標移動後，位於第x個單詞的尾部字符處。    刪除    Command Description     x 刪除一個字符。   dw 刪除一個單詞，可記作delete word。   dxw 刪除x個單詞，可記作delete x words，比如：d2w。   d$ 刪除當前光標位置到行尾的的所有字符，$可記作end of line。   dd 刪除整行，此外dd可接受一個數字前綴x，表示刪除x行，比如：2dd。    撤銷與重做    Command Description     u 撤銷上一個命令，可記作undo。   U 撤銷當前行所有的修改。   CTRL-R 重做，可記作redo。    插入 進入輸入模式，最常用的是i命令，可記作insert。\n但是如果需要追加內容的話，i是無法實現的，此時我們需要使用A命令，可記作append，它使光標位於行尾。\n   Command Description     i 光標位置不變，進入輸入模式，可記作insert。   a 光標向後移動一個字符，並進入插入模式，可記作append。   A 光標處於當前行行尾，並進入插入模式，可記作append。   o 在當前行下添加新行，並進入插入模式，意為open。   O 在當前行上添加新行，並進入插入模式。    替換    Command Description     rx 將當前光標處的字符替換為x，r可記作replace。   R 進入替換模式。   :s/old/new 將當前行第一個old字符串替換成new，s意為substitute。   :s/old/new/g 將當前行所有old字符串替換成new，g可記作globally。   :#,#s/old/new/g #為行號，將指定行之間的所有old字符串替換成new，比如：1,10s/old/new/g。   :%s/old/new/g 將文中所有的old字符串替換成new。   :%s/old/new/gc 將文中所有的old字符串替換成new，但在替換前會顯示確認提示。    修改 如果單詞錯誤過多，用替換來操作是很不方便的，這類情況就需要用到修改命令：\n   Command Description     ce 將當前光標位置到單詞尾部的字符刪除，並進入輸入模式，c可記作change，e可記作end of word。   cw 刪除一個單詞，並進入輸入模式。   cxw 刪除x個單詞，並進入輸入模式。   c$ 刪除當前光標位置到行尾的的所有字符，並進入輸入模式，$可記作end of line。    複製和粘貼 首先我們需要使用v命令選擇需要複製的文本，選中後使用y（yank）進行復制，最後使用p（paste）命令即可粘貼。\ny命令也可以類似d命令那樣：\n yw - 複製一個單詞。 yxw - 複製x個單詞。 y$ - 複製當前光標處到行尾的內容。 yy - 複製整行。  搜索 此處將介紹三個搜索命令：/、?和%：\n   Command Description     / /後面加上要搜索的內容（區分大小寫），然後回車即可進行搜索，n繼續向下搜索，N向前搜索。   ? ?和/用法一致，只是搜索方向相反。   % %會匹配(和)，[和]，{和}。     搜索默認是區分大小寫的，我們可以通過:set ic 忽略大小寫（ignore case）。\n 保存和退出    Command Description     :w :w保存當前的修改，可記作write，也可以指定保存的文件名，比如:w filename，則會將內容保存到filename。   :q :q退出編輯，可記作quit。    w、q可以一起使用，如:wq則表示保存並退出。\n執行外部命令 在Vim中，我們還可以執行外部的命令，比如:!ls則會執行外部命令ls。\n其他命令    Command Description     :no 跳到行no   #G 跳到行#   G 跳到文件底部   gg 跳到文件頂部   CTRL-O 返回上一個位置   CTRL-I 前進下一個位置   :set nu 顯示行號   :set ic 忽略大小寫（ignore case）   :set noic 區分大小寫（no ignore case）    練習 對於筆者來說，光看不練是無法記住的，所以建議經常使用和練習，才能熟練地使用Vim。另外我推薦一款名為vimtutor的練習腳本（安裝Vim自帶的）。\n","date":"2018-06-01","permalink":"https://razonyang.com/zh-tw/posts/vim/primer/","series":null,"tags":["Vim"],"title":"Vim 快速入門"},{"categories":["Programing"],"content":"國內開源鏡像列表。\n 阿里雲 - https://developer.aliyun.com/mirror\r 搜狐 - https://mirrors.sohu.com/\r 網易 - http://mirrors.163.com/\r 中國科學技術大學 - http://mirrors.ustc.edu.cn/\r ","date":"2018-04-12","permalink":"https://razonyang.com/zh-tw/posts/open-source/mirrors/","series":null,"tags":null,"title":"國內開源鏡像彙總"},{"categories":["Programing"],"content":"某城市新開了一家影院，不少人很喜歡去這家影院。該影院也張貼了關於的電影的評級和描述的海報。\n請寫出一條 SQL，返回 id 為奇數，且 description 不是 \u0026ldquo;boring\u0026rdquo; 的電影，並按 rating 降序。\n原題 X city opened a new cinema, many people would like to go to this cinema. The cinema also gives out a poster indicating the movies’ ratings and descriptions.\nPlease write a SQL query to output movies with an odd numbered ID and a description that is not \u0026lsquo;boring\u0026rsquo;. Order the result by rating.\nFor example, table cinema:\n   id movie description rating     1 War great 3D 8.9   2 Science fiction 8.5   3 irish boring 6.2   4 Ice song Fantacy 8.6   5 House card Interesting 9.1    For the example above, the output should be:\n   id movie description rating     5 House card Interesting 9.1   1 War great 3D 8.9    SQL SELECT * FROM cinema WHERE description != \u0026#39;boring\u0026#39; AND id % 2 = 1 ORDER BY rating DESC ","date":"2018-02-02","permalink":"https://razonyang.com/zh-tw/posts/leetcode/database/not-boring-movies/","series":null,"tags":["LeetCode","MySQL"],"title":"LeetCode 數據庫面試題 – 有趣的電影（Not Boring Movies）"},{"categories":["Programing"],"content":"編寫一個方法返回字符串數組的最長公共前綴。\n原題 Write a function to find the longest common prefix string amongst an array of strings.\n分析 依據題意，需要注意以下幾點：\n 區分大小寫 空數組的處理  實現 func longestCommonPrefix(strs []string) string { if len(strs) == 0 { return \u0026#34;\u0026#34; } max := len(strs[0]) for i := 1; i \u0026lt; len(strs); i++ { max = min(max, len(strs[i])) for j := 0; j \u0026lt; max; j++ { if strs[i][j] != strs[i-1][j] { max = j continue } } } return strs[0][:max] } func min(a, b int) int { if a \u0026gt; b { return b } return a } ","date":"2017-12-02","permalink":"https://razonyang.com/zh-tw/posts/leetcode/algorithm/longest-common-prefix/","series":null,"tags":["LeetCode","Go"],"title":"LeetCode 算法題 – Longest Common Prefix"},{"categories":["Programing"],"content":"首先介紹幾個概念 root 和 successor， root 後面拼接一個單詞可以形成一個長單詞，該長單詞被稱為 successor。舉個例子， root 為 an， 拼接單詞 other 形成 another， another 就是 successor。\n現在給出一個包含多個 root 的字典數組和一個句子。請將句子中的 successor 替換成 root。 如果 successor 有多個 root， 則用最短的 root 替換。\n原題 In English, we have a concept called root, which can be followed by some other words to form another longer word - let\u0026rsquo;s call this word successor. For example, the root an, followed by other, which can form another word another.\nNow, given a dictionary consisting of many roots and a sentence. You need to replace all the successor in the sentence with the root forming it. If a successor has many roots can form it, replace it with the root with the shortest length.\nYou need to output the sentence after the replacement.\nExample 1:\nInput: dict = [\u0026quot;cat\u0026quot;, \u0026quot;bat\u0026quot;, \u0026quot;rat\u0026quot;]\rsentence = \u0026quot;the cattle was rattled by the battery\u0026quot;\rOutput: \u0026quot;the cat was rat by the bat\u0026quot;\r Note:\n The input will only have lower-case letters 1 \u0026lt;= dict words number \u0026lt;= 1000 1 \u0026lt;= sentence words number \u0026lt;= 1000 1 \u0026lt;= root length \u0026lt;= 100 1 \u0026lt;= sentence words length \u0026lt;= 1000  分析 如題所述，目的是將句子中的單詞（也就是 successor）用其 root 替換。\n 根據空格將句子分離為一個單詞數組 將單詞逐個尋找其 root，有則替換，無則忽略 將替換後的單詞數組，用空格拼接成新句子返回  另外需要注意的是，要找到最短的 root 進行替換。\n實現 func replaceWords(dict []string, sentence string) string { words := strings.Split(sentence, \u0026#34; \u0026#34;) for i := 0; i \u0026lt; len(words); i++ { for _, v := range dict { if len(words[i]) \u0026gt;= len(v) \u0026amp;\u0026amp; words[i][:len(v)] == v { // in order to find the shortest root, doesn\u0026#39;t break on here  words[i] = v } } } return strings.Join(words, \u0026#34; \u0026#34;) } ","date":"2017-11-22","permalink":"https://razonyang.com/zh-tw/posts/leetcode/algorithm/replace-words/","series":null,"tags":["LeetCode","Go"],"title":"LeetCode 算法題 – Replace Words"},{"categories":["Programing"],"content":"今天安裝了 Chromium 瀏覽器，但是每次打開都會提示 是否設置為默認瀏覽器，卻沒有 Don't Ask Again 的按鈕。\n經過一番搜索，Chromium 支持命令行參數 -no-default-browser-check 可以停止檢查是否默認瀏覽器。\n不過一般桌面的快捷方式應該如何設置呢？\n 筆者使用的是 Linux 桌面版\n 查找快捷方式 一般地，應用的快捷方式會放置在以下三個位置：\n /usr/share/applications /usr/local/share/applications ~/.local/share/applications  不過這裡我們使用 find 命令去尋找 Chromium 的快捷方式：\n$ find / -name chromium-browser.desktop  / 是指在 / 目錄下尋找， -name chromium-browser.desktop 是指尋找名為 chromium-browser.desktop 的目錄和文件。\n 結果：\n/usr/share/applications/chromium-browser.desktop 如果沒有找到，可以嘗試在上述的三個位置進行查找。\n修改快捷方式 找到之後，我們只需要修改快捷方式的執行命令即可：\n$ vi /usr/share/applications/chromium-browser.desktop 在其中的 Exec=chromium-browser 後面添加 -no-default-browser-check 參數，然後保存，重新打開瀏覽器則大功告成。\n","date":"2017-08-12","permalink":"https://razonyang.com/zh-tw/posts/chromium/stop-asking-to-set-as-default/","series":null,"tags":["Chromium"],"title":"Chromium Stop Asking to Set as Default"},{"categories":["Programing"],"content":"給定一個整數數組，如果兩個元素值之和等於給定的值，則返回它們的索引。\n你可以假定只有一個明確的答案，而且不能使用同一元素兩次。\n原題 Given an array of integers, return indices of the two numbers such that they add up to a specific target.\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\nExample:\nGiven nums = [2, 7, 11, 15], target = 9,\nBecause nums[0] + nums[1] = 2 + 7 = 9,\nreturn [0, 1].\n分析  目標：兩元素的索引 依據：兩元素的值之和與給定的值是否相等  實現 雙重循環 按照題意，腦海最開始浮現的解法是用雙重循環，將每個元素和其他元素相加，判斷是否和給定值相等即可，相等則返回結束，否則繼續。\nfunc twoSum(nums []int, target int) []int { for i := 0; i \u0026lt; len(nums); i++ { for j := i + 1; j \u0026lt; len(nums); j++ { if nums[i]+nums[j] == target { return []int{i, j} } } } return []int{} } Map 但是雙重循環的時間複雜度是 O(n^2)，是否有更好的解法呢？ 是否可以使用 Map 呢？如何使用呢？\n根據之前的分析，換個角度看，依據可以理解為：給定值和元素之間的差值，那麼用 Map 來存儲 \u0026lsquo;數值\u0026rsquo; =\u0026gt; \u0026lsquo;索引\u0026rsquo; 的映射的話，則問題迎刃而解。\nfunc twoSum(nums []int, target int) []int { m := map[int]int{} for i := 0; i \u0026lt; len(nums); i++ { m[nums[i]] = i } for i := 0; i \u0026lt; len(nums); i++ { minus := target - nums[i] if j, ok := m[minus]; ok \u0026amp;\u0026amp; i != j { return []int{i, j} } } return []int{} } Map 改良版 上面的 Map 解法的使得時間複雜度從 O(n^2) 將為 O(n)，確切來說是2*O(n)，因為額外用了一個循環，將整數和其索引的映射存儲到 Map 中，如果將兩個循環合併在一起呢？\n仔細思考了下，於是得出以下優化後的代碼，其中 m[nums[i]] = i 放在判斷後面，可以避免多次使用同一元素。\nfunc twoSum(nums []int, target int) []int { m := map[int]int{} for i := 0; i \u0026lt; len(nums); i++ { minus := target - nums[i] if j, ok := m[minus]; ok { return []int{i, j} } // the code placed here can avoid using the same element twice.  m[nums[i]] = i } return []int{} } ","date":"2017-08-02","permalink":"https://razonyang.com/zh-tw/posts/leetcode/algorithm/two-sum/","series":null,"tags":["LeetCode","Go"],"title":"LeetCode 算法題 – Two Sum"},{"categories":["Programing"],"content":"合併兩個二叉樹，如果結點重疊，則該結點值為兩者對應結點之和。否則，將當前對應的非空結點作為當前結點。\n原題 Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not.\nYou need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree.\nExample 1:\nInput:\n Tree 1 Tree 2 1 2 / \\ / \\ 3 2 1 3 / \\ \\ 5 4 7 Output:\n Merged tree:\r3\r/ \\\r4 5\r/ \\ \\ 5 4 7\r Note: The merging process must start from the root nodes of both trees.\n 分析 可以使用遞歸實現：\n 如果其中一棵樹為 null，則直接返回另外一棵樹 如果都是非 null 的二叉樹，則將該結點的值更新為兩者值之和，並向下遞歸，合併兩者的左右結點  實現 func mergeTrees(t1 *TreeNode, t2 *TreeNode) *TreeNode { if t1 == nil { return t2 } else if t2 == nil { return t1 } return \u0026amp;TreeNode{ Val: t1.Val + t2.Val, Left: mergeTrees(t1.Left, t2.Left), Right: mergeTrees(t1.Right, t2.Right), } } ","date":"2017-07-02","permalink":"https://razonyang.com/zh-tw/posts/leetcode/algorithm/merge-two-binary-trees/","series":null,"tags":["LeetCode","Go"],"title":"LeetCode 算法題 – Merge Two Binary Trees"},{"categories":["Programing"],"content":"MySQL拷貝一個數據庫，只需要簡單的幾個命令。\n導出數據庫\n$ mysqldump db1 \u0026gt; dump.sql 創建數據庫\n$ mysqladmin create db2 導入數據\n$ mysql db2 \u0026lt; dump.sql  mysqldump不能使用--databases參數，因為這會使得導出的SQL會包含USE db1命令。\n 原文：Making a Copy of a Database\r","date":"2017-07-01","permalink":"https://razonyang.com/zh-tw/posts/mysql/copying-database/","series":null,"tags":["MySQL"],"title":"MySQL 複製數據庫"},{"categories":["Programing"],"content":"若一個國家的面積大於300萬平方公里，或者人口大於2500萬，則可以稱之為大國。\n請編寫一條 SQL 返回所有大國的 name、population、area。\n原題 There is a table World\n   name continent area population gdp     Afghanistan Asia 652230 25500100 20343000   Albania Europe 28748 2831741 12960000   Algeria Africa 2381741 37100000 188681000   Andorra Europe 468 78115 3712000   Angola Africa 1246700 20609294 100990000    A country is big if it has an area of bigger than 3 million square km or a population of more than 25 million.\nWrite a SQL solution to output big countries' name, population and area.\nFor example, according to the above table, we should output:\n   name population area     Afghanistan 25500100 652230   Algeria 37100000 2381741    SQL SELECT name, population, area FROM World WHERE area \u0026gt; 3000000 OR population \u0026gt; 25000000 ","date":"2017-02-02","permalink":"https://razonyang.com/zh-tw/posts/leetcode/database/big-countries/","series":null,"tags":["LeetCode","MySQL"],"title":"LeetCode 數據庫面試題 – Big Countries"},{"categories":["Programing"],"content":"CSS 文本超過一行顯示省略號 \u0026hellip;\n.text-nowrap { overflow: hidden; white-space: nowrap; text-overflow: ellipsis; } \u0026lt;p class=\u0026#34;text-nowrap\u0026#34; style=\u0026#34;width: 120px;\u0026#34;\u0026gt; A very loooooooooooooooooooooooooooooong text. \u0026lt;/p\u0026gt; \r","date":"2016-12-22","permalink":"https://razonyang.com/zh-tw/posts/css/text-overflow-ellipsis/","series":null,"tags":["CSS"],"title":"CSS 文本超過一行顯示省略號"},{"categories":["Programing"],"content":"CREATE TABLE ... LIKE 基於另一個表的定義創建一個空表，包括原表的所有列屬性和索引。\nCREATE TABLE new_tbl LIKE orig_tbl; 新創建的空表使用原表相同版本的存儲格式。用戶需要擁有對原表的 SELECT 權限。\nLIKE 只能用於基表，而不能用於視圖。\n 注意\n當 LOCK TABLES 語句生效時，不能執行 CREATE TABLE 或 CREATE TABLE ... LIKE。\nCREATE TABLE ... LIKE 和 CREATE TABLE 一樣，會進行相同的檢查，不僅僅是複製 .fim 文件。\n這意味著，如果當前的SQL模式和創建原表時的模式不同時，那麼表的定義可能會被認為是無效的，且語句將會執行失敗。\n 對於 CREATE TABLE ... LIKE，目標表會保存原表已有的列信息，但是不會保存任何數據目錄、索引目錄和外鍵。\n如果要複製臨時表 TEMPORARY，可以使用 CREATE TEMPORARY TABLE ... LIKE。\n原文：CREATE TABLE \u0026hellip; LIKE Syntax\r","date":"2016-11-12","permalink":"https://razonyang.com/zh-tw/posts/mysql/syntax-create-table-like/","series":null,"tags":["MySQL"],"title":"MySQL CREATE TABLE … LIKE"},{"categories":null,"content":"我是 Razon Yang，一名全棧工程師。\n貢獻 \r\r\r\r\r\r\r\r項目 \r\r\r\r\r\r\r\r\r","date":"2016-02-19","permalink":"https://razonyang.com/zh-tw/about/","series":null,"tags":null,"title":"關於"}]