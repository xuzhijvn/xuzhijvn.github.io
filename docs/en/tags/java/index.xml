<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on 🇨🇳🇨🇳🇨🇳🇨🇳🇨🇳</title>
    <link>https://xuzhijvn.github.io/en/tags/java/</link>
    <description>Recent content in Java on 🇨🇳🇨🇳🇨🇳🇨🇳🇨🇳</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>Copyright © 2016-{year} Razon Yang. All Rights Reserved.</copyright>
    <lastBuildDate>Tue, 01 Mar 2022 16:26:31 +0800</lastBuildDate><atom:link href="https://xuzhijvn.github.io/en/tags/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>JVM类的卸载</title>
      <link>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/jvm%E7%B1%BB%E7%9A%84%E5%8D%B8%E8%BD%BD/</link>
      <pubDate>Tue, 01 Mar 2022 16:26:31 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/jvm%E7%B1%BB%E7%9A%84%E5%8D%B8%E8%BD%BD/</guid>
      <description>&lt;p&gt;类的卸载：由JVM自带的类加载器所加载的类，在JVM的生命周期中，始终不会被卸载。JVM本身会始终引用这些类加载器，而这些类加载器始终引用它们所加载的类的Class对象。所以说，这些Class对象始终是可触及的。&lt;/p&gt;
&lt;p&gt;由用户自定义的类加载器所加载的类是可以被卸载的。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Java SPI</title>
      <link>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/java-spi/</link>
      <pubDate>Wed, 22 Dec 2021 16:49:52 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/java-spi/</guid>
      <description>&lt;p&gt;本文不回答SPI是什么？而是结合源码深入剖析SPI该怎么使用。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Log4j2 JNDI远程注入漏洞引发的思考</title>
      <link>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/log4j2-jndi%E8%BF%9C%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83/</link>
      <pubDate>Sun, 19 Dec 2021 22:55:54 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/log4j2-jndi%E8%BF%9C%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83/</guid>
      <description>&lt;p&gt;12月10日凌晨，Apache 开源项目 Log4j 的远程代码执行漏洞细节被公开，由于其利用简单、危害巨大，一时引起不小的热度。本文将以该事件为切入点，浅析其中涉及的一些技术点。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>JVM OOM</title>
      <link>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/jvm-oom/</link>
      <pubDate>Sun, 05 Dec 2021 11:48:50 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/jvm-oom/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Java序列化</title>
      <link>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/java%E5%BA%8F%E5%88%97%E5%8C%96/</link>
      <pubDate>Mon, 27 Sep 2021 11:24:13 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/java%E5%BA%8F%E5%88%97%E5%8C%96/</guid>
      <description>&lt;ol&gt;
&lt;li&gt;对象的类名、实例变量（包括基本类型，数组，对其他对象的引用）都会被序列化；方法、类变量、transient实例变量都不会被序列化；&lt;/li&gt;
&lt;li&gt;Serializable反序列化不会调用构造方法；&lt;/li&gt;
&lt;li&gt;单例类序列化，需要重写readResolve()方法；否则会破坏单例原则；&lt;/li&gt;
&lt;li&gt;序列化对象的&lt;code&gt;引用类型变量&lt;/code&gt;也要实现Serializable接口；&lt;/li&gt;
&lt;li&gt;同一对象序列化多次，只有第一次序列化为二进制流，以后都只是保存序列化编号，不会重复序列化；&lt;/li&gt;
&lt;li&gt;使用Externalizable需要实现它的接口，并提供无参构造方法。&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>几种序列化框架对比</title>
      <link>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/%E5%87%A0%E7%A7%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94/</link>
      <pubDate>Sun, 26 Sep 2021 19:49:15 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/%E5%87%A0%E7%A7%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94/</guid>
      <description>&lt;p&gt;&lt;code&gt;JDK Serializable&lt;/code&gt;, &lt;code&gt;FST&lt;/code&gt; 只适用于Java；&lt;code&gt;Protobuf&lt;/code&gt;, &lt;code&gt;Thrift&lt;/code&gt;, &lt;code&gt;Avro&lt;/code&gt; 支持多种语言，但都需要先通过IDL（接口描述语言，Interface description language）定义Schema；&lt;code&gt;Avro&lt;/code&gt;和&lt;code&gt;Kryo&lt;/code&gt;序列化后的数据最小，&lt;code&gt;FST&lt;/code&gt;和&lt;code&gt;Kryo&lt;/code&gt;序列化时间开销表现最好；&lt;code&gt;Hessian&lt;/code&gt;支持多语言，无需IDL定义Schema，对Java数据类型、语法的支持最佳。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Reactive Streams</title>
      <link>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/reactive-streams/</link>
      <pubDate>Thu, 16 Sep 2021 17:11:30 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/reactive-streams/</guid>
      <description>&lt;p&gt;JDK的异步处理，一直相对较弱，这方面也有很强的第三方框架。最近在学习这方面的内容，将学习过程记录在这里。&lt;/p&gt;
&lt;p&gt;这篇文章里，主要了解Java中异步流处理的顶级概念：Reactive Streams。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Project Reactor</title>
      <link>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/project-reactor/</link>
      <pubDate>Thu, 16 Sep 2021 16:43:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/project-reactor/</guid>
      <description>&lt;p&gt;上一篇文章中，我们介绍了Reactive Streams规范，现在学习一个Reactive Streams规范的流行实现：&lt;code&gt;Project Reactor&lt;/code&gt;的核心项目&lt;code&gt;Reactor Core&lt;/code&gt;。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>volatile</title>
      <link>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/volatile/</link>
      <pubDate>Mon, 13 Sep 2021 15:37:40 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/volatile/</guid>
      <description>&lt;p&gt;JVM volatile用于保证程序&lt;code&gt;可见性&lt;/code&gt;、&lt;code&gt;顺序性&lt;/code&gt;，但是不保证&lt;code&gt;原子性&lt;/code&gt;。volatile实现原理是通过在操作变量之前，多加一个&lt;code&gt;lock前缀指令&lt;/code&gt;，通过汇编可以看到这个前缀指令。&lt;/p&gt;
&lt;p&gt;当谈到顺序性时常会提到&lt;code&gt;内存屏障&lt;/code&gt;，常见的硬件层面&lt;code&gt;内存屏障&lt;/code&gt;有：&lt;code&gt;sfence&lt;/code&gt;    &lt;code&gt;lfence&lt;/code&gt;     &lt;code&gt;mfence&lt;/code&gt; ，&lt;code&gt;lock前缀指令&lt;/code&gt;不是内存屏障，而是一种锁，执行时会锁住内存子系统来确保执行顺序，甚至跨多个CPU，JVM利用lock前缀指令的特点实现了&lt;code&gt;可见性&lt;/code&gt; 和 &lt;code&gt;顺序性&lt;/code&gt;，lock前缀指令实现可见性比较好理解，主要是利用CPU提供的缓存一致性协议（例如Intel的MESI）,当然更差一点的还有lock总线的方式（限制CPU访问内存）。&lt;/p&gt;
&lt;p&gt;JMM层面为了实现&lt;code&gt;顺序性&lt;/code&gt;，又抽象出四个&lt;code&gt;内存屏障&lt;/code&gt;的概念：&lt;code&gt;LoadLoad&lt;/code&gt;     &lt;code&gt;StoreStore&lt;/code&gt;    &lt;code&gt;LoadStore&lt;/code&gt;    &lt;code&gt;StoreLoad&lt;/code&gt;，字节码层面并没有&lt;code&gt;内存屏障&lt;/code&gt;的指令，JVM的C++代码会有四个同名函数与之对应，JVM遇到volatile变量便会在其前后执行对应的函数，从而实现内存屏障，具体来说：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;LoadLoadBarrier
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;volatile&lt;/span&gt; 读操作
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;LoadStoreBarrier
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;StoreStoreBarrier
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;volatile&lt;/span&gt; 写操作
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;StoreLoadBarrie
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>JVM锁优化</title>
      <link>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/jvm%E9%94%81%E4%BC%98%E5%8C%96/</link>
      <pubDate>Thu, 09 Sep 2021 10:46:14 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/jvm%E9%94%81%E4%BC%98%E5%8C%96/</guid>
      <description></description>
    </item>
    
    <item>
      <title>JVM内存模型</title>
      <link>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/jvm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Mon, 06 Sep 2021 00:13:21 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/jvm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</guid>
      <description></description>
    </item>
    
    <item>
      <title>JVM类加载器</title>
      <link>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</link>
      <pubDate>Mon, 06 Sep 2021 00:13:02 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>JVM架构</title>
      <link>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/jvm%E6%9E%B6%E6%9E%84/</link>
      <pubDate>Mon, 06 Sep 2021 00:10:01 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/jvm%E6%9E%B6%E6%9E%84/</guid>
      <description></description>
    </item>
    
    <item>
      <title>JVM垃圾回收</title>
      <link>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</link>
      <pubDate>Sun, 05 Sep 2021 23:48:46 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</guid>
      <description></description>
    </item>
    
    <item>
      <title>String常量池</title>
      <link>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/string%E5%B8%B8%E9%87%8F%E6%B1%A0/</link>
      <pubDate>Sun, 05 Sep 2021 11:54:01 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/string%E5%B8%B8%E9%87%8F%E6%B1%A0/</guid>
      <description></description>
    </item>
    
    <item>
      <title>字节码实战</title>
      <link>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/%E5%AD%97%E8%8A%82%E7%A0%81%E5%AE%9E%E6%88%98/</link>
      <pubDate>Sun, 29 Aug 2021 13:28:08 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/%E5%AD%97%E8%8A%82%E7%A0%81%E5%AE%9E%E6%88%98/</guid>
      <description></description>
    </item>
    
    <item>
      <title>AQS</title>
      <link>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/aqs/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/aqs/</guid>
      <description>AQS作为Java并发编程的基石，在Java同步工具中有广泛应用，例如：ReentrantLock , Semaphore , CountDownLatch ReentrantReadWriteLock , ThreadPoolExecutor
一般来说，自定义同步器要么是独占方式，要么是共享方式，它们也只需实现 tryAcquire / tryRelease , tryAcquireShared / tryReleaseShared 中的一组即可。AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。ReentrantLock是独占锁。
AQS核心思想是：如果被请求的共享资源（state）空闲，那么就将当前请求资源的线程设置为有效的工作线程，将共享资源设置为锁定状态；如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中。
CLH：Craig, Landin, and Hagersten队列，是单向链表，AQS中的队列是CLH变体的虚拟双向队列（FIFO），AQS是通过将每条请求共享资源的线程封装成一个节点来实现锁的分配。
主要原理图如下：
AQS使用一个Volatile的int类型的成员变量state来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作，通过CAS完成对State值的修改。
获得锁 acquire()是独占模式下线程获取共享资源的顶层入口。如果获取到资源，线程直接返回，否则进入等待队列，直到获取到资源为止，且整个过程忽略中断的影响。获取到资源后，线程就可以去执行其临界区代码了。
public final void acquire(int arg) { if (!tryAcquire(arg) &amp;amp;&amp;amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); } 如果再有线程要获取锁，依次在队列中往后排队即可。
tryAcquire()方法尝试去获取独占资源。如果获取成功，则直接返回true，否则直接返回false。需自定义同步器去实现
protected boolean tryAcquire(int arg) { throw new UnsupportedOperationException(); } AQS只是一个框架，具体资源的获取/释放方式交由自定义同步器去实现吗。AQS这里只定义了一个接口，具体资源的获取交由自定义同步器去实现了（通过state的get/set/CAS）！！！至于能不能重入，能不能加塞，那就看具体的自定义同步器怎么去设计了！！
addWaiter(Node)此方法用于将当前线程加入到等待队列的队尾，并返回当前线程所在的结点。
private Node addWaiter(Node mode) { //以给定模式构造结点。mode有两种：EXCLUSIVE（独占）和SHARED（共享） Node node = new Node(Thread.currentThread(), mode); //尝试快速方式直接放到队尾。 Node pred = tail; if (pred !</description>
    </item>
    
    <item>
      <title>CompletableFuture使用详解</title>
      <link>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/completablefuture%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/completablefuture%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/</guid>
      <description>1. runAsync 和 supplyAsync方法 CompletableFuture 提供了四个静态方法来创建一个异步操作。
public static CompletableFuture&amp;lt;Void&amp;gt; runAsync(Runnable runnable) public static CompletableFuture&amp;lt;Void&amp;gt; runAsync(Runnable runnable, Executor executor) public static &amp;lt;U&amp;gt; CompletableFuture&amp;lt;U&amp;gt; supplyAsync(Supplier&amp;lt;U&amp;gt; supplier) public static &amp;lt;U&amp;gt; CompletableFuture&amp;lt;U&amp;gt; supplyAsync(Supplier&amp;lt;U&amp;gt; supplier, Executor executor) 没有指定Executor的方法会使用ForkJoinPool.commonPool() 作为它的线程池执行异步代码。如果指定线程池，则使用指定的线程池运行。以下所有的方法都类同。
runAsync方法不支持返回值。 supplyAsync可以支持返回值。 示例 //无返回值 public static void runAsync() throws Exception { CompletableFuture&amp;lt;Void&amp;gt; future = CompletableFuture.runAsync(() -&amp;gt; { try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { } System.out.println(&amp;#34;run end ...&amp;#34;); }); future.get(); } //有返回值 public static void supplyAsync() throws Exception { CompletableFuture&amp;lt;Long&amp;gt; future = CompletableFuture.</description>
    </item>
    
    <item>
      <title>HashMap和HashTable区别</title>
      <link>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/hashmap%E5%92%8Chashtable%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/hashmap%E5%92%8Chashtable%E5%8C%BA%E5%88%AB/</guid>
      <description> HashMap是HashTable的轻量级版本， HashTable是线程安全的，其方法都被synchronized关键同步 HashMap 把 Hashtable 的 contains 方法去掉了，改成 containsValue 和 containsKey。因为 contains 方法容易让人引起误解。 HashMap允许将 null 作为一个 entry 的 key 或者 value，而 Hashtable 不允许。 HashTable 继承自 Dictionary 类，而 HashMap 是 Java1.2 引进的 Map interface 的一个实现。 Hashtable 和 HashMap 采用的 hash/rehash 算法都大概一样，所以性能不会有很大的差异。 </description>
    </item>
    
    <item>
      <title>Java Agent</title>
      <link>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/java-agent/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/java-agent/</guid>
      <description>Java Agent就是一个可以作为java代理的工具, 简单来说就是一个可供用于编写的java切面, 它的主要功能就是为用户提供了在 JVM 将字节码文件读入内存之后，JVM 使用对应的字节流在 Java 堆中生成一个 Class 对象之前，用户可以对其字节码进行修改的能力，从而 JVM 也将会使用用户修改过之后的字节码进行新的Class 对象的创建(打破了一个类只能加载一次的规则)。
Java Agent的使用对于你自身的代码是无侵入性的。应用场景：热更新。
热更新我们也可以自定义类加载器实现，这种方式的热更新是jvm原生支持的方式, 但是缺点也很明显:
不够灵活, 需要手动修改文件等操作
重复创建类加载器, 并且卸载困难, 会增加系统负担
使用起来具有代码侵入性, 需要对代码进行一定改造
通过 Java Agent完美的解决了我们自定义类加载器实现热更新的缺点。
1.1 JVM启动前静态Instrument 通过启动命令 java -javaagent:agent1.jar -javaagent:agent2.jar -jar MyProgram.jar 在目标程序main方法执行前，先执行agent中定义的 premain 方法
1.2 JVM启动后动态Instrument Java6 以后提供了在目标程序main方法执行后，执行agent的agentmain方法的机制，通过这种机制，我们可以动态修改目标程序已经加载过的字节码。
在Java6 以后实现启动后加载的新实现是Attach API 。Attach API 很简单，只有 2 个主要的类，即VirtualMachine 和 VirtualMachineDescriptor，都在tool.jar 的 com.sun.tools.attach 包里面。
attach实现动态注入的原理如下：
通过VirtualMachine类的attach(pid)方法，便可以attach到一个运行中的java进程上，之后便可以通过loadAgent(agentJarPath)来将agent的jar包注入到对应的进程，然后对应的进程会调用agentmain方法。
既然是两个进程之间通信那肯定的建立起连接，VirtualMachine.attach动作类似TCP创建连接的三次握手，目的就是搭建attach通信的连接。而后面执行的操作，例如vm.loadAgent，其实就是向这个socket写入数据流，接收方target VM会针对不同的传入数据来做不同的处理。
例如：找到当前JVM并加载agent.jar（即attach JVM 和 runing JVM 是同一个 JVM，真正的应用中更多的是不同的两个JVM，这里仅为了测试方便。）
package com.rickiyang.learn.job; import com.</description>
    </item>
    
    <item>
      <title>Java switch表达式支持的数据类型</title>
      <link>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/java-switch%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%94%AF%E6%8C%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/java-switch%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%94%AF%E6%8C%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description>switch(expression){ case value : //语句 break; //可选 case value : //语句 break; //可选 //你可以有任意数量的case语句 default : //可选 //语句 } 这里的 expression 支持：
1、基本数据类型：byte, short, char, int
2、包装数据类型：Byte, Short, Character, Integer
3、枚举类型：Enum
4、 字符串类型：String（Jdk 7+ 开始支持）
为什么不支持long、float、double数据类型？
switch 底层是使用 int 型 来进行判断的，即使是枚举、String类型，最终也是转变成 int 型。由于 long、float、double 型表示范围大于 int 型，因此不支持 long、float、double 类型。 （String类型最终是转成了int类型的hashCode；枚举最终转成了枚举对象的定义顺序，即 ordinal值）
下面举一个使用包装类型和枚举的，其实也不难，注意只能用在 switch 块里面
// 使用包装类型 Integer value = 5; switch (value) { case 3: System.out.println(&amp;#34;3&amp;#34;); break; case 5: System.out.println(&amp;#34;5&amp;#34;); break; default: System.</description>
    </item>
    
    <item>
      <title>Java协程</title>
      <link>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/java%E5%8D%8F%E7%A8%8B/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/java%E5%8D%8F%E7%A8%8B/</guid>
      <description>1. 现状 时至今日，JDK17已经正式发布，Java也没有在语言层面对协程提供原生支持。
一定要在Java中使用协程的话，可以使用诸如quasar, kilim, coroutines 第三方库感受一下，它们的原理基本都是字节码增强 + Java Agent机制，这种做法一是对性能影响很大，对JIT编译器的影响也非常大，另外这些库都几年前就不在更新了，远达不到生产使用的标准。
还可以使用Kotlin混合编程，Kotlin中的协程本质上还是一套基于原生Java Thread API 的封装，和Go中的协程完全不是一个东西，不要混淆，更谈不上什么性能更好，Kotlin中的协程最大的价值是写起来比RxJava的线程切换还要方便，几乎就是用阻塞的写法来完成非阻塞的任务。
openjdk也有正在孵化的官方协程项目loom，其能否release还需拭目以待。
2. 成因 是什么原因导致Oracle一直不着急推出对协程的支持呢？
先返回到问题的本源。当我们希望引入协程，我们想解决什么问题。我想不外乎下面几点：
节省资源：节省内存、节省分配线程的开销（创建和销毁线程要各做一次syscall）、节省大量线程切换带来的开销
与NIO配合实现非阻塞的编程，提高系统的吞吐
使用起来更加舒服顺畅，同步的编程风格编写异步程序
2.1 节省资源 1. 节省内存 我们以常见的Java Web举例，spingboot分配给tomcat的线程池大小默认值是200，即使按照1M线程大小计算，200M的内存占用对于动辄几个G的Java Web应用并不算什么。
即使是IM的场景，有数百万的长链接需要维护，也可以使用NIO+Worker线程应对。
还可以调整线程栈占用内存大小（-Xss1024k 或者 -XX:ThreadStackSize=1024k）
2. 节省线程分配开销 线程池
3. 节省线程切换开销 我们仍然以Java Web举例，大量的线程大部分时间实际上因为IO（发请求/读DB）而挂起，根本不会参与OS的线程切换，现实当中一个最大200线程的服务器可能同一时刻的“活跃线程”总数只有数十而已。其开销没有想象的那么大。
2.2 非阻塞编程 nio 👉 netty
2.3 优雅异步编程 响应式编程库
可见Java对于引入协程机制并不那么紧迫；并且Java不像Golang等新语言，没有历史包袱，它们可以不提供线程只提供协程编程，但是Java如果没有thread，也没有ThreadLocal，@Transactional不起作用了，又没有等价的工具，是不是很郁闷？
参考 为什么 Java 坚持多线程不选择协程？
Kotlin 协程真的比 Java 线程更高效吗？
硬核系列 | 深入剖析 Java 协程
Golang 的 协程调度机制 与 GOMAXPROCS 性能调优</description>
    </item>
    
    <item>
      <title>Java反射</title>
      <link>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/java%E5%8F%8D%E5%B0%84/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/java%E5%8F%8D%E5%B0%84/</guid>
      <description>反射可以在程序运行过程中动态的构造类、获取类的全部信息、调用类型方法。但是，为什么我们要这么做呢？需要构造类，new就好了，需要访问类成员变量、调用方法，直接访问、调用就好了，为什么要通过一大堆反射代码去实现呢？
通常，class在编译期间就确定，JVM在运行时通过类加载器加载确定的class。如果在运行时才确定需要加载什么类，就需要利用java反射。java反射使得程序更加灵活，类似spring的框架将类以全限定名的形成配置在配置文件，然后再通过反射实例化。
参考：
https://blog.csdn.net/Appleyk/article/details/77879073</description>
    </item>
    
    <item>
      <title>Java堆外内存溢出</title>
      <link>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/java%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/java%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/</guid>
      <description>前段时间在做一个实时人脸抓拍项目的时候，遇到了一个堆外内存OOM的问题，现在把思路好好整理一下。
项目中用opencv通过rtsp协议，实时的读取通用网络摄像头的视频帧。因为项目中多处用到了org.opencv.core.Mat这个对象，而Mat对象的构造是通过调用native方法实现的，也就是说构造Mat对象的时候，会在堆外分配内存：
// // C++: Mat::Mat() // // javadoc: Mat::Mat() public Mat() { nativeObj = n_Mat(); return; } // C++: Mat::Mat() private static native long n_Mat(); 堆外分配的内存不受JVM的内存管理。由于又没有主动调用Mat.realse()去释放堆外内存，导致堆外内存OOM。
其实解决的办法很简单，可以在Mat对象使用完毕后直接调用Mat.realse()释放堆外内存。（没有试过，本人使用的下面的方式）
但是，Mat对象充斥着整个项目，要跟踪Mat对象的生命周期显得有点复杂，而且因为太多地方使用了Mat对象，很有可能遗漏调用Mat.realse()释放内存。因此，还是想把这部分内存的释放交由JVM来做，具体的方式是：定期的调用System.gc()执行垃圾回收（很多人说System.gc()只是建议JVM执行垃圾回收，并不是命令，是否执行取决去JVM自己，但是，经我实测，每次调用System.gc()都会触发垃圾回收。），JVM在垃圾回收前会执行每个**空java对象（null）**的finalize()方法，而Mat对象的finalize()方法正好实现了释放内存的逻辑：
@Override protected void finalize() throws Throwable { n_delete(nativeObj); super.finalize(); } // native support for java finalize() private static native void n_delete(long nativeObj); 因为会定时的调用System.gc()触发Full GC, 而Full GC的之前会调用那些不再被引用的Mat对象的finalize()方法释放它的堆外内存，所以间接的实现了由JVM释放堆外内存的目的。
但是，这种做法并不好，因为通过System.gc()强制定期执行Full GC，势必会影响java应用本身。
为何一定要复制到DirectByteBuffer来读写（系统调用）？
GC会回收无用对象，同时还会进行碎片整理，移动对象在内存中的位置，来减少内存碎片。DirectByteBuffer不受GC控制。如果不用DirectByteBuffer而是用HeapByteBuffer，如果在调用系统调用时，发生了GC，导致HeapByteBuffer内存位置发生了变化，但是内核态并不能感知到这个变化导致系统调用读取或者写入错误的数据。所以一定要通过不受GC影响的DirectByteBuffer来进行IO系统调用。
假设我们要从网络中读入一段数据，再把这段数据发送出去的话，采用Non-direct ByteBuffer的流程是这样的：
网络 –&amp;gt; 临时的DirectByteBuffer –&amp;gt; 应用 Non-direct ByteBuffer –&amp;gt; 临时的Direct ByteBuffer –&amp;gt; 网络 这种方式是直接在堆外分配一个内存(即，native memory)来存储数据， 程序通过JNI直接将数据读/写到堆外内存中。因为数据直接写入到了堆外内存中，所以这种方式就不会再在JVM管控的堆内再分配内存来存储数据了，也就不存在堆内内存和堆外内存数据拷贝的操作了。这样在进行I/O操作时，只需要将这个堆外内存地址传给JNI的I/O的函数就好了。</description>
    </item>
    
    <item>
      <title>Java如何绑定线程到指定CPU上执行</title>
      <link>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/java%E5%A6%82%E4%BD%95%E7%BB%91%E5%AE%9A%E7%BA%BF%E7%A8%8B%E5%88%B0%E6%8C%87%E5%AE%9Acpu%E4%B8%8A%E6%89%A7%E8%A1%8C/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/java%E5%A6%82%E4%BD%95%E7%BB%91%E5%AE%9A%E7%BA%BF%E7%A8%8B%E5%88%B0%E6%8C%87%E5%AE%9Acpu%E4%B8%8A%E6%89%A7%E8%A1%8C/</guid>
      <description>绑定核心之后不存在线程的上下文切换，就可以更好的利用CPU缓存。
不知道你是啥感觉，但是我第一次看到这个问题的时候，我是懵逼的。
而且它还是一个面试题。
我懵逼倒不是因为我不知道答案，而是恰好我之前在非常机缘巧合的情况下知道了答案。
我感觉非常的冷门，作为一个考察候选者的知识点出现在面试环节中不太合适，除非是候选者主动提起做过这样的优化。
而且怕就怕面试官也是恰巧在某个书上或者博客中知道这个东西，稍微的看了一下，以为自己学到了绝世武功，然后拿出去考别人。
这样不合适。
说回这个题目。
正常来说，其实应该是属于考察操作系统的知识点范畴。
但是面试官呢又特定的加了“在 Java 中如何实现”。
那我们就聊聊这个问题。
Java线程 在聊如何绑定之前，先铺垫一个相关的背景知识：Java线程的实现。
其实我们都知道 Thread 类的大部分方法都是 native 方法：
在 Java 中一个方法被声明为 native 方法，绝大部分情况下说明这个方法没有或者不能使用平台无关的手段来实现。
说明需要操作的是很底层的东西了，已经脱离了 Java 语言层面的范畴。
抛开 Java 语言这个大前提，实现线程主要是有三种方式：
1.使用内核线程实现（1:1实现） 2.使用用户线程实现（1:N实现） 3.使用用户线程加轻量级进程混合实现（N:M实现）
这三种实现方案，在《深入理解Java虚拟机》的 12.4 小节有详细的描述，有兴趣的同学可以去仔细的翻阅一下。
总之，你要知道的是虽然有这三种不同的线程模型，但是 Java 作为上层应用，其实是感知不到这三种模型之间的区别的。
JVM 规范里面也没有规定，必须使用哪一种模型。
因为操作系统支持是怎样的线程模型，很大程度上决定了运行在上面的 Java 虚拟机的线程怎样去映射，但是这一点在不同的平台上很难达成一致。
所以JVM 规范里面没有、也不好去规定 Java 线程需要使用哪种线程模型来实现。
同时关于本文要讨论的话题，我在知乎上也找到了类似的问题：
https://www.zhihu.com/question/64072646/answer/216184631
这里面有一个R大的回答，大家可以看看一下。
他也是先从线程模型的角度铺垫了一下。
我这里主要说一下使用内核线程实现（1:1实现）的这个模型。
因为我们用的最多的 HotSpot 虚拟机，就是采用 1:1 模型来实现 Java 线程的。
这是个啥意思呢？
说人话就是一个 Java 线程是直接映射为一个操作系统原生线程的，中间没有额外的间接结构。HotSpot 虚拟机也不干涉线程的调度，这事全权交给底下的操作系统去做。
顶多就是设置一个线程优先级，操作系统来调度的时候给个建议。
但是何时挂起、唤醒、分配时间片、让那个处理器核心去执行等等这些关于线程生命周期、执行的东西都是操作系统干的。
这话不是我说的，是R大和周佬都说过这样的话。</description>
    </item>
    
    <item>
      <title>Java安装指南</title>
      <link>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/java%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/java%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/</guid>
      <description>1. 下载JDK 进入Oracle 官方网站下载合适的 JDK 版本，准备安装。
2. 创建目录 执行如下命令，在 /usr/ 目录下创建 java 目录。
mkdir /usr/java cd /usr/java 将下载的文件 jdk-8u151-linux-x64.tar.gz 复制到 /usr/java/ 目录下。
3. 解压 JDK tar -zxvf jdk-8u151-linux-x64.tar.gz 4. 设置环境变量 set java environment JAVA_HOME=/usr/java/jdk1.8.0_151 JRE_HOME=/usr/java/jdk1.8.0_151/jre CLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin export JAVA_HOME JRE_HOME CLASS_PATH PATH 使修改生效：
source /etc/profile 5. 测试 执行如下命令进行测试。
java -version 若显示 Java 版本信息，则说明 JDK 安装成功：
java version &amp;#34;1.8.0_151&amp;#34; Java(TM) SE Runtime Environment (build 1.8.0_151-b12) Java HotSpot(TM) 64-Bit Server VM (build 25.</description>
    </item>
    
    <item>
      <title>Java对象的hashCode方法</title>
      <link>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/java%E5%AF%B9%E8%B1%A1%E7%9A%84hashcode%E6%96%B9%E6%B3%95/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/java%E5%AF%B9%E8%B1%A1%E7%9A%84hashcode%E6%96%B9%E6%B3%95/</guid>
      <description>java中的Object类的hashCode方法是一个native方法，查看native源码过于困难，所以暂且认为 Object类的hashCode生成规则是：hash(对象的内存地址+一些其他信息)
java中String类的 hashCode方法 比较直观，源码如下：
public int hashCode() { int h = hash; if (h == 0 &amp;amp;&amp;amp; value.length &amp;gt; 0) { char val[] = value; for (int i = 0; i &amp;lt; value.length; i++) { h = 31 * h + val[i]; } hash = h; } return h; } 生成规则：s[0]*31^(n-1) + s[1]*31^(n-2) + &amp;hellip; + s[n-1]
为什么是素数31？
素数：根据素数的特点，一个数与素数相乘，得到结果只能被1、这个数、素数本身整除。因此，按照 s[0]*31^(n-1) + s[1]*31^(n-2) + &amp;hellip; + s[n-1] 生成的hashCode越不容易发生碰撞。
31：哈希计算速度快。可用移位和减法来代替乘法。现代的VM可以自动完成这种优化，如31 * i = (i &amp;laquo; 5) - i。</description>
    </item>
    
    <item>
      <title>JIT即时编译</title>
      <link>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/jit%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/jit%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91/</guid>
      <description>JIT (just-in-time compilation) 是指程序在运行过程中对热点代码进行编译的过程，编译后的机器码存入CodeCache，下次再遇到这段代码，就会从CodeCache中读取机器码，直接执行，以此来提升程序运行的性能。
有的JVM全程都是JIT编译运行，例如：JRockit；有的JVM是解释器 + JIT运行，例如：HotSpot, J9（也支持AOT）；有的JVM没有解释器，只支持AOT+JIT或者纯AOT，例如：Excelsior JET
以HotSpot JVM举例，JIT还可以分为C1, C2等。C1编译快，执行效率低；C2编译慢，效率高。可以通过 -XX:+TieredCompilation 开启分层编译，对热点代码先C1编译以尽快进入到编译执行模式；随着应用继续运行，收集到足够多的指标后，再进行C2编译，以期获得最好的执行效率。
JIT在编译过程中会采用一些优化手段，包括：公共子表达式消除、数组范围检查消除、方法内联、逃逸分析（目的是栈上分配、同步消除、标量替换、循环变型、窥孔优化与寄存器分配）
1. 编译器与解释器 不做特别说明的话，我们讲的，
编译器：程序运行前将其编译成机器码的程序
解释器：程序运作中逐行解释源码得到结果的程序
特别注意的是，解释器也是一个程序，输入源码，输出结果，并没有显示的将源码转换成机器码的过程 解释器与 JIT
无论是编译器还是解释器，从 源码 到结果都需要将源码经过：词法分析 -&amp;gt; 语法分析 -&amp;gt; 语义分析 处理，
一个比较简单的编译器的处理步骤看起来：
编译流程： 源码 [字符流] - 词法分析 -&amp;gt; 单词（token）流 - 语法分析 -&amp;gt; 语法树 / 抽象语法树 - 语义分析 -&amp;gt; 标注了属性的抽象语法树 - 代码生成 -&amp;gt; 目标代码 执行流程： 目标代码 - 操作系统/硬件 -&amp;gt; 执行结果 狭义的解释器处理步骤看起来：
解释执行流程： 源码 [字符流] - 需要做词法分析+语法分析+类型检查的字符流解释器 -&amp;gt; 执行结果 特别注意的是，解释器真正的输入往往并直接是源码，使用解释器实现的编程语言实现里，通常：
至少会在解释执行前做完语法分析，然后通过树解释器来实现解释执行； 兼顾易于实现、跨平台、执行效率这几点，会选择使用字节码解释器实现解释执行。 为什么大多数解释器都将AST转化成字节码再用虚拟机执行，而不是直接解释AST？</description>
    </item>
    
    <item>
      <title>OOM实战</title>
      <link>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/oom%E5%AE%9E%E6%88%98/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/oom%E5%AE%9E%E6%88%98/</guid>
      <description>《深入理解Java虚拟机》中将OOM划分为: Java堆溢出、虚拟机栈和本地方法栈溢出、方法区和运行时常量池溢出、本机直接内存溢出
1. Java堆溢出 /** * JDK1.6/JDK1.8 * * Java堆内存溢出异常测试 * * VM Args: -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError * * @author xuzhijun.online * @date 2019年4月22日 */ public class HeapOOM { static class OOMObject{ } public static void main(String[] args) { List&amp;lt;OOMObject&amp;gt; list = new ArrayList&amp;lt;OOMObject&amp;gt;(); while(true) { list.add(new OOMObject()); } } } 运行结果：
java.lang.OutOfMemoryError: Java heap space Dumping heap to java_pid3404.hprof ... Heap dump file created [22045981 bytes in 0.663 secs] 处理方法：</description>
    </item>
    
    <item>
      <title>ThreadLocal</title>
      <link>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/threadlocal/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/threadlocal/</guid>
      <description>ThreadLocal 是一个线程的本地变量，也就意味着这个变量是线程独有的，是不能与其他线程共享的，这样就可以避免资源竞争带来的多线程的问题，这种解决多线程的安全问题和lock(这里的lock 指通过synchronized 或者Lock 等实现的锁) 是有本质的区别的:
lock 的资源是多个线程共享的，所以访问的时候需要加锁。 ThreadLocal 是每个线程都有一个副本，是不需要加锁的。 lock 是通过时间换空间的做法。 ThreadLocal 是典型的通过空间换时间的做法。 当然他们的使用场景也是不同的，关键看你的资源是需要多线程之间共享的还是单线程内部共享的。
ThreadLocal 的使用是非常简单的，看下面的代码：
public class Test { public static void main(String[] args) { ThreadLocal&amp;lt;String&amp;gt; local = new ThreadLocal&amp;lt;&amp;gt;(); //设置值 local.set(&amp;#34;hello word&amp;#34;); //获取刚刚设置的值 System.out.println(local.get()); } } ThreadLocal的数据结构 为什么ThreadLocalMap 采用开放地址法来解决哈希冲突? ThreadLocal 往往存放的数据量不会特别大，这个时候开放地址法简单的结构会显得更省空间（链地址法需要额外的指针空间）
常用的hash解决方法有：拉链法（HashMap，指针需要占用空间）、开发地址（如果发生冲突，那就基于冲突位置再次探测寻址，直至不冲突，适用于记录总数可以预知的场景，如果位桶不够用就得扩容，扩容影响性能）、再hash（如果第1个hash函数冲突，那就使用第2个，多次hash是有时间成本的）
ThreadLocal应用场景 传递参数 ThreadLocal用于传递参数及优势
保证线程安全 SimpleDateFormat是线程不安全的，例如下面的写法会报错：
日期转换的一个工具类
public class DateUtil { private static final SimpleDateFormat sdf = new SimpleDateFormat(&amp;#34;yyyy-MM-dd HH:mm:ss&amp;#34;); public static Date parse(String dateStr) { Date date = null; try { date = sdf.</description>
    </item>
    
    <item>
      <title>ThreadLocal线程单例</title>
      <link>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/threadlocal%E7%BA%BF%E7%A8%8B%E5%8D%95%E4%BE%8B/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/threadlocal%E7%BA%BF%E7%A8%8B%E5%8D%95%E4%BE%8B/</guid>
      <description>ThreadLocal 保证的是单个线程内部访问的是同一个实例，不同线程访问的不是同一个实例。
package test; public class Singleton { private static final ThreadLocal&amp;lt;Singleton&amp;gt; singleton = new ThreadLocal&amp;lt;Singleton&amp;gt;() { @Override protected Singleton initialValue() { return new Singleton(); } }; public static Singleton getInstance() { return singleton.get(); } private Singleton() { } } package test; public class T implements Runnable { @Override public void run() { Singleton instance = Singleton.getInstance(); System.out.println(instance); } } 测试类：
package test; public class Test { public static void main(String[] args){ System.</description>
    </item>
    
    <item>
      <title>ThreadPoolExecutor</title>
      <link>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/threadpoolexecutor/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/threadpoolexecutor/</guid>
      <description>如果采用有界BlockingQueue，队列满后启用maximumPoolSize，达到maximumPoolSize上限后走RejectedExecutionHandler的逻辑；如果采用无界BlockingQueue，maximumPoolSize设置无效。
构造方法 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&amp;lt;Runnable&amp;gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) { if (corePoolSize &amp;lt; 0 || maximumPoolSize &amp;lt;= 0 || maximumPoolSize &amp;lt; corePoolSize || keepAliveTime &amp;lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.acc = System.getSecurityManager() == null ? null : AccessController.getContext(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.</description>
    </item>
    
    <item>
      <title>你了解的可见性可能是错的</title>
      <link>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/%E4%BD%A0%E4%BA%86%E8%A7%A3%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E5%8F%AF%E8%83%BD%E6%98%AF%E9%94%99%E7%9A%84/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/%E4%BD%A0%E4%BA%86%E8%A7%A3%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E5%8F%AF%E8%83%BD%E6%98%AF%E9%94%99%E7%9A%84/</guid>
      <description>背景 这篇文章最开始再我的群里面有讨论过，当时想写的这篇文章的，但是因为一些时间的关系所以便没有写。最近阅读微信文章的时候发现了一篇零度写的一篇文章《分享一道阿里Java并发面试题》，对于有关Java并发性技术的文章我一般还是挺感兴趣的，于是阅读了一下，整体来说还是挺不错的，但是其中犯了一个验证可见性的问题。由于微信文章回复不方便讨论，于是我便把之前一些和群友的讨论在这里写出来。
如何测试可见性问题 因为在群里面我们习惯的有每周一问，也就由我或者群友发现一些由意思的问题然后提问给大家，让大家参与讨论，当时我提出了一个如何测试vlolatile可见性的问题，首先在Effective Java给出了一个测试volatile可见性的例子:
import java.util.concurrent.*; public class Test { private static /*volatile*/ boolean stop = false; public static void main(String[] args) throws Exception { Thread t = new Thread(new Runnable() { public void run() { int i = 0; while (!stop) { i++; // System.out.println(&amp;#34;hello&amp;#34;); } } }); t.start(); Thread.sleep(1000); TimeUnit.SECONDS.sleep(1); System.out.println(&amp;#34;Stop Thread&amp;#34;); stop = true; } } 这里大家可以复制上面的代码，你会发现这里程序永远不会结束，在零度的那篇文章中也给出了一个测试可见性的例子:
public class ThreadSafeCache { int result; public int getResult() { return result; } public synchronized void setResult(int result) { this.</description>
    </item>
    
    <item>
      <title>实现线程超时的几种方式</title>
      <link>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E8%B6%85%E6%97%B6%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E8%B6%85%E6%97%B6%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</guid>
      <description>1. 基于线程的join(long millis)方法 其实这个方法比较牵强，因为它主要作用是用来多个线程之间进行同步的。但因为它提供了这个带参数的方法（所以这也给了我们一个更广泛的思路，就是一般带有超时参数的方法我们都可以尝试着用它来实现超时结束任务），所以我们可以用它来实现。注意这里的参数的单位是固定的毫秒，不同于接下来的带单位的函数。具体用法请看示例：
public class JoinTest { public static void main(String[] args) { Task task1 = new Task(&amp;#34;one&amp;#34;, 4); Task task2 = new Task(&amp;#34;two&amp;#34;, 2); Thread t1 = new Thread(task1); Thread t2 = new Thread(task2); t1.start(); try { t1.join(2000); // 在主线程中等待t1执行2秒 } catch (InterruptedException e) { System.out.println(&amp;#34;t1 interrupted when waiting join&amp;#34;); e.printStackTrace(); } t1.interrupt(); // 这里很重要，一定要打断t1,因为它已经执行了2秒。 t2.start(); try { t2.join(1000); } catch (InterruptedException e) { System.out.println(&amp;#34;t2 interrupted when waiting join&amp;#34;); e.</description>
    </item>
    
    <item>
      <title>对象初始化顺序</title>
      <link>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F/</guid>
      <description>父类静态成员变量、父类静态代码块 👉🏿 子类静态成员变量、子类静态代码块 👉🏿 父类成员变量、父类代码块 👉🏿 父类构造方法 👉🏿 子类成员变量、子类代码块 👉🏿 子类构造方法
Java中类及方法的加载顺序
Java类加载顺序</description>
    </item>
    
    <item>
      <title>泛型</title>
      <link>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/%E6%B3%9B%E5%9E%8B/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/%E6%B3%9B%E5%9E%8B/</guid>
      <description>泛型的好处 提供了一种类型安全检测机制 提升程序可读性 通配符 通配符的出现是为了指定泛型中的类型范围。
通配符有 3 种形式。
&amp;lt;?&amp;gt;被称作无限定的通配符。 &amp;lt;? extends T&amp;gt;被称作有上限的通配符。 &amp;lt;? super T&amp;gt;被称作有下限的通配符。 ? 其实代表的是未知类型，所以涉及到 ? 时的操作，一定与具体类型无关。
有人说，&amp;lt;?&amp;gt;提供了只读的功能，也就是它删减了增加具体类型元素的能力，只保留与具体类型无关的功能。它不管装载在这个容器内的元素是什么类型，它只关心元素的数量、容器是否为空？我想这种需求还是很常见的吧。
有同学可能会想，&amp;lt;?&amp;gt;既然作用这么渺小，那么为什么还要引用它呢？ 
个人认为，提高了代码的可读性，程序员看到这段代码时，就能够迅速对此建立极简洁的印象，能够快速推断源码作者的意图。
类型擦除 在泛型类被类型擦除的时候，之前泛型类中的类型参数部分如果没有指定上限，如 &amp;lt;T&amp;gt;则会被转译成普通的 Object 类型，如果指定了上限如 &amp;lt;T extends String&amp;gt;则类型参数就被替换成类型上限。
类型擦除带来的局限性 正常情况下，因为泛型的限制，编译器不让最后一行代码编译通过，因为类似不匹配，但是，基于对类型擦除的了解，利用反射，我们可以绕过这个限制。
那么，利用反射，我们绕过编译器去调用 add 方法。
public class ToolTest { public static void main(String[] args) { List&amp;lt;Integer&amp;gt; ls = new ArrayList&amp;lt;&amp;gt;(); ls.add(23); //	ls.add(&amp;#34;text&amp;#34;); try { Method method = ls.getClass().getDeclaredMethod(&amp;#34;add&amp;#34;,Object.class); method.invoke(ls,&amp;#34;test&amp;#34;); method.invoke(ls,42.9f); } catch (NoSuchMethodException e) { // TODO Auto-generated catch block e.</description>
    </item>
    
    <item>
      <title>浮点数运算</title>
      <link>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97/</guid>
      <description>结论 Java中单精度和双精度采用IEEE 754表示，能有效运算的范围大致是小数点后7位和15位 如果Java中默认的float和double不能满足你的精度要求，可以用BigDecimal，理论上它的精度只受限制与机器内存 如果BigDecimal仍无法满足需求，例如是无限循环小数的运算，可考虑设计分数系统保证计算的精度 1. IEEE 754 精度上限 编程语言中的浮点数一般都是 32 位的单精度浮点数 float 和 64 位的双精度浮点数 double，部分语言会使用 float32 或者 float64 区分这两种不同精度的浮点数。想要使用有限的位数表示全部的实数是不可能的，不用说无限长度的小数和无理数，因为长度的限制，有限小数在浮点数中都无法精确的表示。
单精度浮点数 float 总共包含 32 位，其中 1 位表示符号、8 位表示指数，最后 23 位表示小数； 双精度浮点数 double 总共包含 64 位，其中 1 位表示符号，11 位表示指数，最后 52 位表示小数； 我们以单精度浮点数 0.15625 为例:
通过上图中的公式 (sign * 2^{exp}* (1+fraction))可以将浮点数的二进制表示转换成十进制的小数。0.15625 虽然还可以用单精度的浮点数精确表示，但是 0.1 和 0.2 只能使用浮点数表示近似的值：
因为 0.2 和 0.1 只是指数稍有不同，所以上图中只展示了 0.1 对应的单精度浮点数，从上图的结果我们可以看出，0.1 和 0.2 在浮点数中只能用近似值来代替，精度十分有限，因为单精度浮点数的小数位为 23，双精度的小数位为 52，同时都隐式地包含首位的 1，所以它们的精度在十进制中分别是(log_{10}(2^{24})\approx 7.22) 和 (log_{10}(2^{53})\approx 15.</description>
    </item>
    
    <item>
      <title>生产问题定位</title>
      <link>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D/</guid>
      <description>排除应用之外的影响因素： top(cpu)、free(内存)、df(磁盘)、dstat(网络流量)、pstack、vmstat、st1race(底层系统调用)
top 定位CPU 最高的进程
top -Hp pid 定位使用 CPU 最高的线程（或者 ps -mp pid -o THREAD,tid,time）
printf &#39;0x%x&#39; tid 线程 id 转化 16 进制
jstack pid | grep tid 找到线程堆栈
5.1 gc线程（如下是查看gc情况的几种方式）
👉🏿 查看gc 日志
👉🏿 jstat -gcutil 进程号 统计间隔毫秒 统计次数（缺省代表一次统计）
👉🏿 如果所在公司有对应用进行监控的组件当然更方便（比如Prometheus + Grafana）
结合内存dump日志分析：
哪些对象导致的内存溢出导致频繁gc（尤其是full gc）
如果不是内存溢出导致频繁gc，也可能是代码或者第三方依赖的包中有显示的System.gc()调用，此时可以通过添加 -XX:+DisableExplicitGC来禁用JVM对显示GC的响应。
在分配堆外内存的时候，内存不足时会显示的调用System.gc()，如果显示gc被禁用，则可能会导致堆外内存溢出，所以堆外内存的回收最好就不要依赖jvm，主动回收吧。
5.2 业务线程
👉🏿 关注线程堆栈的lock字段
👉🏿 jstack -l pid | grep BLOCKED 查看阻塞态线程堆栈</description>
    </item>
    
    <item>
      <title>线程安全的单例的几种实现方法</title>
      <link>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%8D%95%E4%BE%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%8D%95%E4%BE%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/</guid>
      <description>1. 使用synchronized 饱汉：双重检查锁定、饿汉、静态内部类、枚举 都属于利用synchronized同步原理实现
1.1 饱汉：双重检查锁定（double-checked locking） public class SingleTon { // 静态实例变量加上volatile private static volatile SingleTon instance; // 私有化构造函数 private SingleTon() {} // 双重检查锁 public static SingleTon getInstance() { if (instance == null) { synchronized(SingleTon.class){ if(instance == null){ instance = new SingleTon(); } } } return instance; } 1.2 饿汉 public class Singleton { private static Singleton instance = new Singleton(); private Singleton() { } public static Singleton getInstance() { return instance; } } 1.</description>
    </item>
    
    <item>
      <title>线程状态</title>
      <link>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/</guid>
      <description>Linux线程的状态与调度 Java线程的6种状态及切换 Java 线程的生命周期中，在 Thread 类里有一个枚举类型 State，定义了线程的几种状态，分别有：
New Runnable Blocked Waiting Timed Waiting Terminated 上图有误，根据Blocked注释可知：线程从Waiting或Timed Waiting状态恢复后，应该是去到Blocked状态
Thread state for a thread blocked waiting for a monitor lock. A thread in the blocked state is waiting for a monitor lock to enter a synchronized block/method or reenter a synchronized block/method after calling Object.wait.
sleep和wait区别 1、sleep方法是Thread类的静态方法；
wait方法是Object类的成员方法
2、sleep方法使当前线程暂停执行指定的时间，让出cpu给其他线程，但是它的监控状态依然保持着，当指定的时间到了又会自动恢复运行状态。在调用sleep方法后，线程不会释放对象锁；
而当调用wait方法时，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池处于准备状态。
3、sleep方法有可能会抛出异常，所以需要进行异常处理；
wait方法不需要处理
4、sleep方法可以在任何地方使用；
wait方法只能在同步方法和同步代码块中使用
参考 Linux线程的状态与调度</description>
    </item>
    
    <item>
      <title>脚手架</title>
      <link>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/%E8%84%9A%E6%89%8B%E6%9E%B6/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/%E8%84%9A%E6%89%8B%E6%9E%B6/</guid>
      <description>1. 什么是java脚手架 其实就是java工程模板，你可以把一些通用的组件抽象成一个模板，下次开发的时候基于这个模板开发，避免重复造轮子。像apache默认就提供了很多模板（archetype）
2. 创建archetype 假如你已经有了一个maven项目，想给该项目创建一个archetype模板。你需要cd 到项目根目录下执行(pom.xml同级目录)。
mvn archetype:create-from-project 执行完后，生成的target类似这样：
3. 生成archetype模板 先cd target/generated-sources/archetype/ 然后执行：
mvn install 执行成功后，执行crawl命令：
mvn archetype:crawl 在本地仓库的根目录生成archetype-catalog.xml骨架配置文件:
来看一看它里面的内容:
4. 使用archetype模板 执行mvn archetype:generate -DarchetypeCatalog=local从本地archetype模板中创建项目。
mvn archetype:generate -DarchetypeCatalog=local 然后会让你选择模板序号和groupId artifactId version和package信息：
至此，项目创建成功!
当然，也可以使用IDEA来帮我们用图形界面使用archetype模板创建项目：
这里的信息根据archetype-catalog.xml中的填写，如果是本地导入Repository可以不填或者填&amp;rsquo;local&amp;rsquo;。既然提到本地，那么自然可以想到，可以将脚手架发布到nexus私服。发布到私服可以参看这里：https://www.cnblogs.com/woshimrf/p/maven-artifact-demo.html</description>
    </item>
    
    <item>
      <title>锁</title>
      <link>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/%E9%94%81/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/%E9%94%81/</guid>
      <description>阿里面试，问了我乐观锁、悲观锁、AQS、sync和Lock，这个回答让我拿了offer
阿里面试官：说一下公平锁和非公平锁的区别？</description>
    </item>
    
    <item>
      <title>零拷贝</title>
      <link>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/%E9%9B%B6%E6%8B%B7%E8%B4%9D/</link>
      <pubDate>Fri, 27 Aug 2021 11:15:10 +0800</pubDate>
      
      <guid>https://xuzhijvn.github.io/en/zh-cn/posts/code/java/%E9%9B%B6%E6%8B%B7%E8%B4%9D/</guid>
      <description>简介 零拷贝的“零”是指用户态和内核态间copy数据的次数为零。
传统的数据copy（文件到文件、client到server等）涉及到四次用户态内核态切换、四次copy。四次copy中，两次在用户态和内核态间copy需要CPU参与、两次在内核态与IO设备间copy为DMA方式不需要CPU参与。零拷贝避免了用户态和内核态间的copy、减少了Java零拷贝机制解析核态间的切换。
DMA(Direct Memory Access，直接内存存取) 是所有现代电脑的重要特色，它允许不同速度的硬件装置来沟通，而不需要依赖于CPU 的大量中断负载。 DMA控制器，接管了数据读写请求，减少CPU的负担。这样一来，CPU能高效工作了。 现代硬盘基本都支持DMA。
使用Zero Copy前后对比：
使用前：
使用后：
Linux支持的(常见)零拷贝 mmap内存映射 sendfile Sendfile With DMA Scatter/Gather Copy splice
无论是传统IO方式，还是引入零拷贝之后，2次DMA copy 是都少不了的。因为两次DMA都是依赖硬件完成的。
实际上，零拷贝时有广义和狭义之分的。 广义零拷贝： 能减少拷贝次数，减少不必要的数据拷贝，就算作“零拷贝”。 这是目前，对零拷贝最为广泛的定义，我们需要知道的是，这是广义上的零拷贝，并不是操作系统 意义上的零拷贝。
Java零拷贝机制解析 Linux提供的领拷贝技术 Java并不是全支持，支持2种(内存映射mmap、sendfile)；
NIO提供的内存映射：MappedByteBuffer
NIO提供的sendfile：FileChannel.transferTo() FileChannel.transferFrom()
适用场景 数据不需要应用程序计算处理的场景，例如：访问静态资源
参考 Java中的零拷贝
Java零拷贝</description>
    </item>
    
  </channel>
</rss>
